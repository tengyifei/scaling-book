<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> How to Parallelize a Transformer for Training | How To Scale Your Model </title> <meta name="author" content=" "> <meta name="description" content="Here we discuss four main parallelism schemes used during LLM training: data parallelism, fully-sharded data parallelism (FSDP), tensor parallelism, and pipeline parallelism. For each, we calculate at what point we become bottlenecked by communication."> <meta name="keywords" content="scaling, jax, llms, transformers, tpus, google, deepmind, parallelism, pallas"> <link rel="stylesheet" href="/scaling-book/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/scaling-book/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/scaling-book/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/scaling-book/assets/css/jekyll-pygments-themes-vs.css?4ee1a2facd1a8a76347f4bd43a740500" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/scaling-book/assets/img/favicon.png?fddbd8c2ec231ba2060e67c85de32a55"> <link rel="stylesheet" href="/scaling-book/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jax-ml.github.io/scaling-book/training/"> <script src="/scaling-book/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/scaling-book/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/scaling-book/assets/js/distillpub/template.v2.js"></script> <script src="/scaling-book/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">{{page._styles}}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "How to Parallelize a Transformer for Training",
            "description": "Here we discuss four main parallelism schemes used during LLM training: data parallelism, fully-sharded data parallelism (FSDP), tensor parallelism, and pipeline parallelism. For each, we calculate at what point we become bottlenecked by communication.",
            "published": "February 04, 2025",
            "authors": [
              
              {
                "author": "Jacob Austin",
                "authorURL": "https://www.jacobaustin.org/",
                "affiliations": [
                  {
                    "name": "Google DeepMind",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Sholto Douglas",
                "authorURL": "https://x.com/_sholtodouglas",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Roy Frostig",
                "authorURL": "https://cs.stanford.edu/~rfrostig/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Anselm Levskaya",
                "authorURL": "https://anselmlevskaya.com/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Charlie Chen",
                "authorURL": "https://x.com/charliexychen",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Sharad Vikram",
                "authorURL": "https://sharadvikram.com/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Federico Lebron",
                "authorURL": "https://fedelebron.com/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Peter Choy",
                "authorURL": "https://x.com/pchoy95",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Vinay Ramasesh",
                "authorURL": "https://x.com/vinayramasesh",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Albert Webson",
                "authorURL": "https://representation.ai/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Reiner Pope<sup>*</sup>",
                "authorURL": "https://x.com/reinerpope",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <script>
    function goToTop() {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }

    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
      // Get the button:
      let mybutton = document.getElementById("top-button");

      if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
        mybutton.style.display = "block";
      } else {
        mybutton.style.display = "none";
      }
  }
  </script> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/scaling-book"> How To Scale Your Model </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="left-button section-button"><a href="../transformers"><svg viewbox="-78.5 0 512 512"><path d="M257 64L291 98 128 262 291 426 257 460 61 262 257 64Z"></path></svg></a></div> <div class="right-button section-button"><a href="../applied-training"><svg viewbox="-78.5 0 512 512"><path d="M98 460L64 426 227 262 64 98 98 64 294 262 98 460Z"></path></svg></a></div> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/scaling-book/"> </a> </li> <li class="nav-item nav-hidden"><a class="nav-link" onclick="goToTop()" id="top-button" style="display: none;">Back to Top</a></li> <li class="nav-item nav-hidden"><p class="nav-link"></p></li> <li class="nav-item nav-hidden"><a class="nav-link" href="../transformers">Previous Part</a></li> <li class="nav-item nav-hidden"><a class="nav-link" href="../applied-training">Next Part</a></li> <li class="nav-item nav-hidden"><p class="nav-link"></p></li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Sections </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/scaling-book/index">Part 0. Introduction</a> <a class="dropdown-item " href="/scaling-book/roofline">Part 1. Intro to Rooflines</a> <a class="dropdown-item " href="/scaling-book/tpus">Part 2. All About TPUs</a> <a class="dropdown-item " href="/scaling-book/sharding">Part 3. Sharded Matmuls</a> <a class="dropdown-item " href="/scaling-book/transformers">Part 4. Transformers</a> <a class="dropdown-item " href="/scaling-book/training">Part 5. Training</a> <a class="dropdown-item " href="/scaling-book/applied-training">Part 6. Training LLaMA</a> <a class="dropdown-item " href="/scaling-book/inference">Part 7. Inference</a> <a class="dropdown-item " href="/scaling-book/applied-inference">Part 8. Serving LLaMA</a> <a class="dropdown-item " href="/scaling-book/profiling">Part 9. Profiling</a> <a class="dropdown-item " href="/scaling-book/jax-stuff">Part 10. All About JAX</a> <a class="dropdown-item " href="/scaling-book/conclusion">Part 11. Conclusions</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>How to Parallelize a Transformer for Training</h1> <p>Part 5 of <a href="/scaling-book">How To Scale Your Model</a> (<a href="../transformers">Part 4: Transformers</a> | <a href="../applied-training">Part 6: Training LLaMA</a>)</p> <p>Here we discuss four main parallelism schemes used during LLM training: data parallelism, fully-sharded data parallelism (FSDP), tensor parallelism, and pipeline parallelism. For each, we calculate at what point we become bottlenecked by communication.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#what-do-we-mean-by-scaling">What Do We Mean By Scaling?</a> </div> <div> <a href="#"></a> </div> <ul> <li> <a href="#data-parallelism">Data Parallelism</a> </li> <li> <a href="#fully-sharded-data-parallelism-fsdp">Fully-Sharded Data Parallelism (FSDP)</a> </li> <li> <a href="#tensor-parallelism">Tensor Parallelism</a> </li> <li> <a href="#mixed-fsdp-and-tensor-parallelism">Mixed FSDP and Tensor Parallelism</a> </li> <li> <a href="#pipelining">Pipelining</a> </li> <li> <a href="#scaling-between-pods">Scaling Between Pods</a> </li> </ul> <div> <a href="#takeaways-from-llm-training-on-tpus">Takeaways from LLM Training on TPUs</a> </div> <div> <a href="#some-problems-to-work">Some Problems to Work</a> </div> <div> <a href="#appendix">Appendix</a> </div> </nav> </d-contents> <h2 id="what-do-we-mean-by-scaling">What Do We Mean By Scaling?</h2> <p>The goal of “model scaling” is to be able to increase the number of chips used for training or inference while achieving a proportional, linear increase in throughput (we call this <em>strong scaling</em>). While performance on a single chip depends on the trade-off between memory bandwidth and FLOPs, performance at the cluster level depends on hiding inter-chip communication by overlapping it with useful FLOPS. This is non-trivial, because increasing the number of chips increases the communication load while reducing the amount of per-device computation we can use to hide it. As we saw in <a href="../sharding">Section 3</a>, sharded matrix multiplications often require expensive AllGathers or ReduceScatters that can block the TPUs from doing useful work. The goal of this section is to find out when these become <em>too expensive.</em></p> <p>In this section, we’ll discuss four common parallelism schemes: (pure) <strong>data parallelism, fully-sharded data parallelism</strong> (FSDP / ZeRO sharding), <strong>tensor parallelism</strong> (also known as model parallelism), and (briefly) <strong>pipeline parallelism</strong>. For each, we’ll show what communication cost we incur and at what point that cost starts to bottleneck our compute cost.<d-footnote>We'll focus on communication bounds — since while memory capacity constraints are important, they typically do not bound us when using rematerialization (activation checkpointing) and a very large number of chips during pre-training. We also do not discuss expert parallelism here for MoEs — which expands the design space substantially, only the base case of a dense Transformer.</d-footnote> For this section, you can focus solely on inter-chip communication costs, since as long as we have a large enough single-chip batch size, the transfer of data from HBM to MXU is already overlapped with computation.</p> <p>We’ll use the following notation to simplify calculations throughout this section.</p> <table> <thead> <tr> <th style="text-align: left">Notation</th> <th style="text-align: left">Meaning (model parameters)</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">D</td> <td style="text-align: left"> <strong>d</strong><sub>model</sub> ( the hidden dimension/residual stream dim)</td> </tr> <tr> <td style="text-align: left">F</td> <td style="text-align: left"> <strong>d</strong><sub>ff</sub> (the feed-forward dimension)</td> </tr> <tr> <td style="text-align: left">B</td> <td style="text-align: left">Batch dimension (number of tokens in the batch; total, not per-device)</td> </tr> <tr> <td style="text-align: left">T</td> <td style="text-align: left">Sequence length</td> </tr> <tr> <td style="text-align: left">L</td> <td style="text-align: left">Number of layers in the model</td> </tr> </tbody> </table> <table> <thead> <tr> <th style="text-align: left">Notation</th> <th style="text-align: left">Meaning (hardware characteristic)</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">C</td> <td style="text-align: left">FLOPS/s per chip</td> </tr> <tr> <td style="text-align: left">W</td> <td style="text-align: left">Network bandwidth (bidirectional, often subscripted as e.g. $W_{\text{ici}}$ or $W_{\text{dcn}}$</td> </tr> <tr> <td style="text-align: left">X</td> <td style="text-align: left">Number of chips along mesh axis X</td> </tr> <tr> <td style="text-align: left">Y</td> <td style="text-align: left">Number of chips along an alternate mesh axis, labeled Y</td> </tr> <tr> <td style="text-align: left">Z</td> <td style="text-align: left">Number of chips along a third mesh axis, labeled Z</td> </tr> </tbody> </table> <p>For simplicity’s sake, <strong>we’ll approximate a Transformer as a stack of MLP blocks</strong> — attention is a comparatively small fraction of the FLOPs for larger models as we saw in <a href="../transformers">Section 4</a>. We will also ignore the gating matmul, leaving us with the following simple structure for each layer:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/simple-transformer-480.webp 480w,/scaling-book/assets/img/simple-transformer-800.webp 800w,/scaling-book/assets/img/simple-transformer-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/simple-transformer.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> a simplified Transformer layer. We treat each FFW block as a stack of two matrices <b>W<sub>in</sub></b>: <code>bf16[D, F]</code> (up-projection) and <b>W<sub>out</sub></b>: <code>bf16[F, D]</code> (down-projection) with an input <b>In</b>: <code>bf16[B, D]</code>.</figcaption> </figure> <p>Here are the 4 parallelism schemes we will discuss. Each scheme can be thought of as uniquely defined by a sharding for <strong>In</strong>, <strong>W<sub>in</sub>, W<sub>out</sub>, and Out</strong> in the above diagram.</p> <p><strong>1. Data parallelism:</strong> <em>activations sharded along batch, parameters and optimizer state are replicated on each device. Communication only occurs during the backwards pass.</em></p> \[\text{In}[B_X, D] \cdot_D W_\text{in}[D, F] \cdot_F W_\text{out}[F, D] \rightarrow \text{Out}[B_X, D]\] <p><strong>2. Fully-sharded data parallelism (FSDP or ZeRO-3):</strong> <em>activations sharded along batch (like pure data parallelism), parameters sharded along same mesh axis and AllGathered just-in-time before use in forward pass. Optimizer state also sharded along batch. Reduces duplicated memory.</em></p> \[\text{In}[B_X, D] \cdot_D W_\text{in}[D_X, F] \cdot_F W_\text{out}[F, D_X] \rightarrow \text{Out}[B_X, D]\] <p><strong>3. Tensor parallelism (also called Megatron sharding or model parallelism):</strong> <em>activations sharded along D ($d_\text{model}$), parameters sharded along F ($d_{ff}$). AllGather and ReduceScatter activations before and after each block. Compatible with FSDP.</em></p> \[\text{In}[B, D_Y] \cdot_D W_\text{in}[D, F_Y] \cdot_F W_\text{out}[F_Y, D] \rightarrow \text{Out}[B, D_Y]\] <p><strong>4. Pipeline parallelism:</strong> <em>weights sharded along the layer dimension, activations microbatched and rolled along the layer dimension. Communication between pipeline stages is minimal (just moving activations over a single hop). To abuse notation:</em></p> \[\text{In}[L_Z, B, D][i] \cdot_D W_\text{in}[L_Z, D, F][i] \cdot_F W_\text{out}[L_Z, F, D][i] \rightarrow \text{Out}[L_Z, B, D_Y][i]\] <h3 id="data-parallelism">Data Parallelism</h3> <p><strong>Syntax:</strong> \(\text{In}[B_X, D] \cdot_D W_\text{in}[D, F] \cdot_F W_\text{out}[F, D] \rightarrow \text{Out}[B_X, D]\)</p> <p><strong>When your model fits on a single chip with even a tiny batch size (&gt;240 tokens, so as to be compute-bound), you should always use simple data parallelism.</strong> Pure data parallelism splits our activations across any number of TPUs so long as the number of TPUs is smaller than our batch size. The forward pass involves no communication, but at the end of every step, each performs an <strong>AllReduce on their gradients in order to synchronize them before updating the parameters.</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/data-parallelism-480.webp 480w,/scaling-book/assets/img/data-parallelism-800.webp 800w,/scaling-book/assets/img/data-parallelism-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/data-parallelism.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> a diagram of pure data parallelism (forward pass). Our activations (left) are fully sharded along the batch dimension and our weights are fully replicated, so each TPU has an identical copy of the weights. This means the total memory of our weights is increased by a factor of N, but no communication is required on the forward-pass.</figcaption> </figure> <details><summary>Here’s the full algorithm for the forward and backwards pass. We abuse notation to write dL/dOut as dOut, purely for compactness.</summary> <div class="algorithm"> <p><strong>Pure Data Parallelism Algorithm:</strong></p> <p><strong>Forward pass:</strong> need to compute Loss[B<sub>X</sub>]</p> <ol> <li>Tmp[B<sub>X</sub>, F] = In[B<sub>X</sub>, D] *<sub>D</sub> W<sub>in</sub>[D, F]</li> <li>Out[B<sub>X</sub>, D] = Tmp[B<sub>X</sub>, F] *<sub>F</sub> W<sub>out</sub>[F, D]</li> <li>Loss[B<sub>X</sub>] = …</li> </ol> <p><strong>Backward pass:</strong> need to compute dW<sub>out</sub>[F, D], dW<sub>in</sub>[D, F]</p> <ol> <li>dOut[B<sub>X</sub>, D] = …</li> <li>dW<sub>out</sub>[F, D] {U<sub>X</sub>} = Tmp[B<sub>X</sub>, F] *<sub>B</sub> dOut[B<sub>X</sub>, D]</li> <li>dW<sub>out</sub>[F, D] = <strong>AllReduce</strong>(dW<sub>out</sub>[F, D] {U<sub>X</sub>}) (<em>not on critical path, can be done async</em>)</li> <li>dTmp[B<sub>X</sub>, F] = dOut[B<sub>X</sub>, D] *<sub>D</sub> W<sub>out</sub>[F, D]</li> <li>dW<sub>in</sub>[D, F] {U<sub>X</sub>} = In[B<sub>X</sub>, D] *<sub>B</sub> dTmp[B<sub>X</sub>, F]</li> <li>dW<sub>in</sub>[D, F] = <strong>AllReduce</strong>(dW<sub>in</sub>[D, F] {U<sub>X</sub>}) (<em>not on critical path, can be done async</em>)</li> <li>dIn[B<sub>X</sub>, D] = dTmp[B<sub>X</sub>, F] *<sub>F</sub> W<sub>in</sub>[D, F] (<em>needed for previous layers</em>)</li> </ol> </div> <p>We ignore the details of the loss function and abbreviate $\text{Tmp} = W_\text{in} \cdot \text{In}$. Note that, although our final loss is the average <strong>AllReduce</strong>(Loss[B<sub>X</sub>]), we only need to compute the AllReduce on the backward pass when averaging weight gradients.</p> </details> <p>Note that the forward pass has no communication — <strong>it’s all in the backward pass</strong>! The backward pass also has the great property that the AllReduces aren’t in the “critical path”, meaning that each AllReduce can be performed whenever it’s convenient and doesn’t block you from performing subsequent operations. The overall communication cost <em>can still bottleneck us</em> if it exceeds our total compute cost, but it is much more forgiving from an implementation standpoint. We’ll see that model/tensor parallelism doesn’t have this property.</p> <p><strong>Why do this?</strong> Pure data parallelism reduces activation memory pressure by splitting our activations over the batch dimension, allowing us to almost arbitrarily increase batch size as long as we have more chips to split the batch dimension over. Especially during training when our activations often dominate our memory usage, this is very helpful.</p> <p><strong>Why not do this?</strong> Pure data parallelism does nothing to reduce memory pressure from model parameters or optimizer states, which means pure data parallelism is rarely useful for interesting models at scale where our parameters + optimizer state don’t fit in a single TPU. To give a sense of scale, if we train with parameters in bf16 and optimizer state in fp32 with Adam<d-footnote>Adam stores parameters, first order and second order accumulators. Since the params are in bfloat16 and optimizer state is in float32, this gives us `2 + 8 = 10` bytes per parameters.</d-footnote>, the largest model we can fit has \(\text{TPU memory} / 10\) parameters, so e.g. on a TPUv5p pod with 96GB of HBM and pure data parallelism this is about 9B parameters.</p> <p class="takeaway"><strong>Takeaway</strong>: the largest model we can train with Adam and pure data parallelism has \(\text{num_params} = \text{HBM per device} / 10\). For TPU v5p this is roughly 9B parameters.<d-footnote>Note that this doesn't include gradient checkpoints, so this wouldn't actually be useful. This is an absolute lower bound with a batch of 1 token.</d-footnote></p> <p><em>To make this useful for real models during training, we’ll need to at least partly shard the model parameters or optimizer.</em></p> <p><strong>When do we become bottlenecked by communication?</strong> As we can see above, we have two AllReduces per layer, each of size \(2DF\) (for bf16 weights). When does data parallelism make us communication bound?</p> <p>As in the table above, let $C$ = per-chip FLOPs, $W_{\text{ici}}$ = <strong>bidirectional</strong> network bandwidth, and $X$ = number of shards across which the batch is partitioned<d-footnote>We assume this partitioning is done over an ICI mesh, so the relevant network bandwidth is $W_\text{ici}$</d-footnote>. Let’s calculate the time required to perform the relevant matmuls, \(T_\text{math}\), and the required communication time \(T_\text{comms}\). Since this parallelism scheme requires no communication in the forward pass, we only need to calculate these quantities for the backwards pass.</p> <p><em>Communication time:</em> From a previous section we know that the time required to perform an AllReduce in a 1D mesh depends only on the total bytes of the array being AllReduced and the ICI bandwidth $W_\text{ici}$; specifically the AllReduce time is $2 \cdot \text{total bytes} / W_\text{ici}$. Since we need to AllReduce for both $W_\text{in}$ and $W_\text{out}$, we have 2 AllReduces per layer. Each AllReduce is for a weight matrix, i.e. an array of $DF$ parameters, or $2DF$ bytes. Putting this all together, the total time for the AllReduce in a single layer is</p> \[\begin{align} T_\text{comms} &amp;= \frac{2 \cdot 2 \cdot 2 \cdot D \cdot F}{W_\text{ici}}. \\ \end{align}\] <p><em>Matmul time:</em> Each layer comprises two matmuls in the forward pass, or four matmuls in the backwards pass, each of which requires $2(B/X)DF$ FLOPs. Thus</p> \[\begin{align} T_\text{math} &amp;= \frac{2 \cdot 2 \cdot 2 \cdot B \cdot L \cdot D \cdot F}{X \cdot C} \\ \end{align}\] <p>Since we overlap, the total time per layer is the max of these two quantities:</p> \[\begin{aligned} T &amp;\approx \max(\frac{8 \cdot B \cdot D \cdot F}{X \cdot C}, \frac{8 \cdot D \cdot F}{W_\text{ici}}) \\ T &amp;\approx 8 \cdot D \cdot F \cdot \max(\frac{B}{X \cdot C}, \frac{1}{W_\text{ici}}) \end{aligned}\] <p>We become compute-bound when \(T_\text{math}/T_\text{comms} &gt; 1\), or when</p> \[\begin{align} \frac{B}{X} &gt; \frac{C}{W_\text{ici}}. \end{align}\] <p>The upshot is that, to remain compute-bound with data parallelism, we need the per-device batch size \(B / X\) to exceed the ICI operational intensity, $C / W_\text{ici}$. This is ultimately a consequence of the fact that the computation time scales with the per-device batch size, while the communication time is independent of this quantity (since we are transferring model weights). Note the resemblance of the $B &gt; C/W_\text{ici}$ condition to the single-device compute-bound rule $B &gt; 240$; in that case as well, the rule came from the fact that computation time scaled with batch size while data-transfer size was (in the $B \ll F, D$ regime) independent of batch size.</p> <p>Let’s put in some real numbers to get a sense of scale. For TPUv5p, <code class="language-plaintext highlighter-rouge">C=4.6e14</code> and <code class="language-plaintext highlighter-rouge">W=2 * 9e10</code> for 1D data parallelism over ICI, so <strong>our batch size per chip must be at least 2,550 to avoid being communication-bound</strong>. Since we can do data parallelism over multiple axes, if we dedicate all three axes of a TPUv5p pod to pure data parallelism, we 3x our bandwidth $W_\text{ici}$ and can scale down to only BS=850 per TPU or 7.6M tokens per batch per pod (of 8960 chips)! <strong>This tells us that it’s fairly hard to become bottlenecked by pure data parallelism!</strong></p> <p class="takeaway"><strong>Note on context parallelism:</strong> throughout this section, we use $B$ to refer to the total batch size in tokens. Clearly, however, our batch is made up of $K$ sequences of $T$ tokens each, so how can we do this? As far as the MLP is concerned, <em>tokens are tokens</em>! It doesn’t matter if they belong to the same batch or two different batches. So we are more or less free to do data parallelism over both the batch and sequence dimension: we call this context parallelism or sequence parallelism, but you can think of it as simply being another kind of data parallelism. Attention is trickier than the MLP since we do some cross-sequence computation, but this can be handled by gathering KVs or Qs during attention and carefully overlapping FLOPs and comms (typically using something called “ring attention”). Throughout this section, we will just ignore our sequence dimension entirely and assume some amount of batch or sequence parallelism.</p> <h3 id="fully-sharded-data-parallelism-fsdp">Fully-Sharded Data Parallelism (FSDP)</h3> <p><strong>Syntax:</strong> \(\text{In}[B_X, D] \cdot_D W_\text{in}[D_X, F] \cdot_F W_\text{out}[F, D_X] \rightarrow \text{Out}[B_X, D]\)</p> <p>Fully-sharded data parallelism (often called FSDP or ZeRO-sharding<d-cite key="zero"></d-cite>) splits the model optimizer states and weights across the data parallel shards and efficiently gathers and scatters them as needed. <strong>Compared to pure data parallelism, FSDP drastically reduces per-device memory usage and saves on backward pass FLOPs, with very minimal overhead.</strong></p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/fsdp-480.webp 480w,/scaling-book/assets/img/fsdp-800.webp 800w,/scaling-book/assets/img/fsdp-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/fsdp.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> FSDP shards the contracting dimension of the MLP weights along the data dimension. This reduces memory but (from Section 3) requires us to gather the weights for W before we perform the matmul. Note that the activations (left) <it>are not sharded along the contracting dimension</it>, which is what forces us to gather. <b>Note that our weight optimizer state is likewise sharded along the contracting dimension.</b></figcaption> </figure> <p>You’ll remember (from <a href="../sharding">Section 3</a>) that an AllReduce can be decomposed into an AllGather and a ReduceScatter. This means that, instead of doing the full gradient AllReduce for standard data parallelism, we can shard the weights and optimizer states across chips, AllGather them at each layer during the forward pass and ReduceScatter across the weights during the backward pass at no extra cost.</p> <details><summary>Here’s the full algorithm for FSDP.</summary> <div class="algorithm"> <p><strong>Fully-Sharded Data Parallelism (FSDP):</strong></p> <p><strong>Forward pass:</strong> need to compute Loss[B<sub>X</sub>]</p> <ol> <li>W<sub>in</sub>[D, F] = <strong>AllGather</strong>(W<sub>in</sub>[D<sub>X</sub>, F]) (<em>not on critical path, can do it during previous layer</em>)</li> <li>Tmp[B<sub>X</sub>, F] = In[B<sub>X</sub>, D] *<sub>D</sub> W<sub>in</sub>[D, F] (<em>can throw away W<sub>in</sub>[D, F] now</em>)</li> <li>W<sub>out</sub>[F, D] = <strong>AllGather</strong>(W<sub>out</sub>[F, D<sub>X</sub>]) (<em>not on critical path, can do it during previous layer</em>)</li> <li>Out[B<sub>X</sub>, D] = Tmp[B<sub>X</sub>, F] *<sub>F</sub> W<sub>out</sub>[F, D]</li> <li>Loss[B<sub>X</sub>] = …</li> </ol> <p><strong>Backward pass:</strong> need to compute dW<sub>out</sub>[F, D<sub>X</sub>], dW<sub>in</sub>[D<sub>X</sub>, F]</p> <ol> <li>dOut[B<sub>X</sub>, D] = …</li> <li>dW<sub>out</sub>[F, D] {U<sub>X</sub>} = Tmp[B<sub>X</sub>, F] *<sub>B</sub> dOut[B<sub>X</sub>, D]</li> <li>dW<sub>out</sub>[F, D<sub>X</sub>] = <strong>ReduceScatter</strong>(dW<sub>out</sub>[F, D] {U<sub>X</sub>}) (<em>not on critical path, can be done async</em>)</li> <li>W<sub>out</sub>[F, D] = <strong>AllGather</strong>(W<sub>out</sub>[F, D<sub>X</sub>]) (<em>can be done ahead of time</em>)</li> <li>dTmp[B<sub>X</sub>, F] = dOut[B<sub>X</sub>, D] *<sub>D</sub> W<sub>out</sub>[F, D] <em>(can throw away W<sub>out</sub>[F, D] here)</em> </li> <li>dW<sub>in</sub>[D,F] {U<sub>X</sub>} = dTmp[B<sub>X</sub>, F] *<sub>B</sub> In[B<sub>X</sub>, D]</li> <li>dW<sub>in</sub>[D<sub>X</sub>, F] = <strong>ReduceScatter</strong>(dW<sub>in</sub>[D, F] {U<sub>X</sub>}) <em>(not on critical path, can be done async)</em> </li> <li>W<sub>in</sub>[D, F] = <strong>AllGather</strong>(W<sub>in</sub>[D<sub>X</sub>, F]) (<em>can be done ahead of time</em>)</li> <li>dIn[B<sub>X</sub>, D] = dTmp[B<sub>X</sub>, F] *<sub>F</sub> W<sub>in</sub>[D, F] (<em>needed for previous layers) (can throw away W<sub>in</sub>[D, F] here</em>)</li> </ol> </div> </details> <p>This is also called “ZeRO Sharding”, from “ZeRo Overhead sharding” since we don’t perform any unnecessary compute or store any unnecessary state. ZeRO-{1,2,3} are used to refer to sharding the optimizer states, gradients, and weights in this way, respectively. Since all have the same communication cost, we can basically always do ZeRO-3 sharding, which shards the parameters, gradients, and optimizer states across a set of devices.</p> <p><strong>Why would we do this?</strong> Standard data parallelism involves a lot of duplicated work. Each TPU AllReduces the full gradient, then updates the full optimizer state (identical work on all TPUs), then updates the parameters (again, fully duplicated). For ZeRO sharding (sharding the gradients/optimizer state), instead of an AllReduce, you can ReduceScatter the gradients, update only your shard of the optimizer state, update a shard of the parameters, then AllGather the parameters as needed for your forward pass.</p> <p><strong>When do we become bottlenecked by communication?</strong> Our relative FLOPs and comms costs are exactly the same as pure data parallelism, since each AllReduce in the backward pass has become an AllGather + ReduceScatter. Recall that an AllReduce is implemented as an AllGather and a ReduceScatter, each with half the cost. Here we model the forward pass since it has the same FLOPs-to-comms ratio as the backward pass:</p> \[\begin{aligned} T_{math} &amp;= \frac{2 \cdot 2 \cdot B \cdot D \cdot F}{X \cdot C} \\ T_{comm} &amp;= \frac{2 \cdot 2 \cdot D \cdot F}{W_\text{ici}} \\ T &amp;\approx \max\left(\frac{4 \cdot B \cdot D \cdot F}{X \cdot C}, \frac{4 \cdot D \cdot F}{W_\text{ici}}\right) \\ T &amp;\approx 4 \cdot D \cdot F \cdot \max\left(\frac{B}{X \cdot C}, \frac{1}{W_\text{ici}}\right) \end{aligned}\] <p>Therefore, as with pure data-parallelism, we are compute bound when \(B / X &gt; C / W_\text{ici}\), i.e. when the per-device batch size $B/X$ exceeds the “ICI operational intensity” $C/W_\text{ici}$ (<code class="language-plaintext highlighter-rouge">4.59e14 / 1.8e11 = 2550</code> for v5p). This is great for us, because it means if our per-device batch size is big enough to be compute-bound for pure data-parallelism, we can — without worrying about leaving the compute-bound regime — simply upgrade to FSDP, saving ourselves a massive amount of parameter and optimizer state memory! Though we did have to add communication to the forward pass, this cost is immaterial since it just overlaps with forward-pass FLOPs.</p> <p class="takeaway"><strong>Takeaway:</strong> both FSDP and pure data parallelism become bandwidth bound on TPUv5 when the batch size per device is less than $2550 / n_\text{axes}$.</p> <p>For example, DeepSeek-V2 (one of the only recent strong model to release information about its training batch size) used a batch size of ~40M tokens. <strong>This would allow us to scale to roughly 47,000 chips, or around 5 TPUv5 pods, before we hit a bandwidth limit.</strong></p> <p>For LLaMA-3 70B, which was trained for approximately <code class="language-plaintext highlighter-rouge">6.3e24 (15e12 * 70e9 * 6)</code> FLOPs, we could split a batch of 16M tokens over roughly <code class="language-plaintext highlighter-rouge">16e6 / (2550 / 3) = 18,823</code> chips (roughly 2 pods of 8960 chips), each with <code class="language-plaintext highlighter-rouge">4.59e14</code> FLOPs running at 50% peak FLOPs utilization (often called MFU), and <strong>train it in approximately 17 days</strong>. Not bad! But let’s explore how we can do better.</p> <p class="takeaway"><strong>Note on critical batch size</strong>: somewhat unintuitively, we become more communication bottlenecked as our total batch size decreases (with fixed chip number). Data parallelism and FSDP let us scale to arbitrarily many chips so long as we can keep increasing our batch size! However, in practice, as our batch size increases, we tend to see diminishing returns in training since our gradients become almost noise-free. We also sometimes see training instability. Thus, the game of finding an optimal sharding scheme in the “unlimited compute regime” often starts from a fixed batch size, determined by scaling laws, and a known (large) number of chips, and then aims to find a partitioning that allows us to fit that small batch size on so many chips.</p> <h3 id="tensor-parallelism">Tensor Parallelism</h3> <p><strong>Syntax:</strong> \(\text{In}[B, D_Y] \cdot_D W_\text{in}[D, F_Y] \cdot_F W_\text{out}[F_Y, D] \rightarrow \text{Out}[B, D_Y]\) (we use \(Y\) to eventually combine with FSDP)</p> <p>In a fully-sharded data-parallel AllReduce we move the weights across chips. We can also shard the feedforward dimension of the model and move the activations during the layer — this is called “1D model parallelism” or Megatron sharding<d-cite key="megatron"></d-cite>. This can unlock a smaller efficient batch size per pod. The figure below shows an example of a single matrix sharded in this way:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/model-parallelism-480.webp 480w,/scaling-book/assets/img/model-parallelism-800.webp 800w,/scaling-book/assets/img/model-parallelism-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/model-parallelism.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> an example of basic tensor parallelism. Since we're only sharding our activations over Y (unlike in FSDP where we shard over X), we replicate our activations over X. Using our standard syntax, this is <b>A</b>[B, D<sub>Y</sub>] * <b>B</b>[D, F<sub>Y</sub>] -&gt; <b>C</b>[B, F<sub>Y</sub>]. Because we're only sharding over one of the contracting dimensions, we typically AllGather the activations <b>A</b> before the matmul.</figcaption> </figure> <p>As noted, <strong>In[B, D<sub>Y</sub>] *<sub>D</sub> W<sub>in</sub>[D, F<sub>Y</sub>] *<sub>F</sub> W<sub>out</sub>[F<sub>Y</sub>, D] -&gt; Out[B, D<sub>Y</sub>] means we have to gather our activations before the first matmul. This is cheaper than ZeRO sharding when the activations are smaller than the weights.</strong> This is typically true only with some amount of ZeRO sharding added (which reduces the size of the gather). This is one of the reasons we tend to mix ZeRO sharding and model parallelism.</p> <details><summary>Here’s the algorithm for tensor parallelism!</summary> <div class="algorithm"> <p><strong>Tensor Parallelism:</strong></p> <p><strong>Forward pass:</strong> need to compute Loss[B]</p> <ol> <li>In[B, D] = <strong>AllGather</strong>(In[B, D<sub>Y</sub>]) <em>(on critical path)</em> </li> <li>Tmp[B, F<sub>Y</sub>] = In[B, D] *<sub>D</sub> W<sub>in</sub>[D, F<sub>Y</sub>] <em>(not sharded along contracting, so no comms)</em> </li> <li>Out[B, D] {U<sub>Y</sub>} = Tmp[B, F<sub>Y</sub>] *<sub>F</sub> W<sub>out</sub>[F<sub>Y</sub>, D]</li> <li>Out[B, D<sub>Y</sub>] = <strong>ReduceScatter</strong>(Out[B, D] {U<sub>Y</sub>}) <em>(on critical path)</em> </li> <li>Loss[B] = …</li> </ol> <p><strong>Backward pass:</strong> need to compute dW<sub>out</sub>[F<sub>Y</sub>, D], dW<sub>in</sub>[D, F<sub>Y</sub>]</p> <ol> <li>dOut[B, D<sub>Y</sub>] = …</li> <li>dOut[B, D] = <strong>AllGather</strong>(dOut[B, D<sub>Y</sub>]) <em>(on critical path)</em> </li> <li>dW<sub>out</sub>[F<sub>Y</sub>, D] = Tmp[B, F<sub>Y</sub>] *<sub>B</sub> dOut[B, D]</li> <li>dTmp[B, F<sub>Y</sub>] = dOut[B, D] *<sub>D</sub> W<sub>out</sub>[F<sub>Y</sub>, D] <em>(can throw away dOut[B, D] here)</em> </li> <li>In[B, D] = <strong>AllGather</strong>(In[B, D<sub>Y</sub>]) <em>(this can be skipped by sharing with (1) from the forward pass)</em> </li> <li>dW<sub>in</sub>[D, F<sub>Y</sub>] = dTmp[B, F<sub>Y</sub>] *<sub>B</sub> In[B, D]</li> <li>dIn[B, D] {U.Y} = dTmp[B, F<sub>Y</sub>] *<sub>F</sub> W<sub>in</sub>[D, F<sub>Y</sub>] <em>(needed for previous layers)</em> </li> <li>dIn[B, D<sub>Y</sub>] = <strong>ReduceScatter</strong>(dIn[B, D] {U.Y}) <em>(on critical path)</em> </li> </ol> </div> </details> <p>One nice thing about tensor parallelism is that it interacts nicely with the two matrices in our Transformer forward pass. Naively, we would do an AllReduce after each of the two matrices. But here we first do <strong>In[B, D<sub>Y</sub>] * W<sub>in</sub>[D, F<sub>Y</sub>] -&gt; Tmp[B, F<sub>Y</sub>]</strong> and then <strong>Tmp[B, F<sub>Y</sub>] * W<sub>out</sub>[F<sub>Y</sub>, D] -&gt; Out[B, D<sub>Y</sub>]</strong>. This means we AllGather <strong>In</strong> at the beginning, and ReduceScatter <strong>Out</strong> at the end, rather than doing an AllReduce.</p> <p><strong>How costly is this?</strong> Let’s only model the forward pass - the backwards pass is just the transpose of each operation here. In 1D model parallelism we AllGather the activations before the first matmul, and ReduceScatter them after the second, sending two bytes at a time (bf16). Let’s figure out when we’re bottlenecked by communication.</p> \[\begin{align} T_{math} &amp; = \frac{4 \cdot B \cdot D \cdot F}{Y \cdot C} \\ T_{comms} &amp; = \frac{2 \cdot 2 \cdot (B \cdot D)}{W_\text{ici}}\\ \textnormal{T} &amp; \approx \max \left(\frac{4 \cdot B \cdot D \cdot F}{Y \cdot C}, \frac{2 \cdot 2 \cdot (B \cdot D)}{W_\text{ici}}\right) \end{align}\] <p>Noting that we want compute cost to be greater than comms cost, we get:</p> \[\begin{align} \frac{4 \cdot B \cdot D \cdot F}{Y \cdot C} &gt; \frac{2 \cdot 2 \cdot (B \cdot D)}{W_\text{ici}} \end{align}\] \[\begin{align} \frac{F}{Y \cdot C} &gt; \frac{1}{W_\text{ici}} \end{align}\] \[\begin{align} F &gt; Y \cdot \frac{C}{W_\text{ici}} \end{align}\] <p>Thus for instance, for TPUv5p, \(C / W_{ici} = 2550\) in bf16, so we can only do tensor parallelism up to \(Y &lt; F / 2550\). When we have multiple ICI axes, our \(T_\text{comms}\) is reduced by a factor of $n_\text{axes}$, so we get \(Y &lt; n_\text{axes} * F / 2550\).</p> <p class="takeaway"><strong>Takeaway</strong>: model parallelism becomes communication bound when \(Y &gt; n_\text{axes} * F / 2550\). For most models this is between 8 and 16-way model parallelism.</p> <p><strong>Note that this doesn’t depend on the precision of the computation</strong>, since e.g. for int8, on TPUv5p, \(C_\text{int8} / W_{ici}\) is \(5100\) instead of \(2550\) but the comms volume is also halved, so the two factors of two cancel.</p> <p><strong>Let’s think about some examples:</strong></p> <ul> <li> <p>On TPUv4p with LLaMA 3-70B with \(D = 8192,\) \(F \approx 30,000\), we can comfortably do 8-way model parallelism, but will be communication bound on 16 way model parallelism. The required F for model 8 way model sharding is 20k.</p> </li> <li> <p>For Gemma 7B, \(F \approx 50k\), so we become communication bound with 19-way model parallelism. That means we could likely do 16-way and still see good performance.</p> </li> </ul> <h3 id="mixed-fsdp-and-tensor-parallelism">Mixed FSDP and Tensor Parallelism</h3> <p><strong>Syntax:</strong> \(\text{In}[B_X, D_Y] \cdot_D W_\text{in}[D_X, F_Y] \cdot_F W_\text{out}[F_Y, D_X] \rightarrow \text{Out}[B_X, D_Y]\)</p> <p>The nice thing about FSDP and tensor parallelism is that they can be combined. By sharding <strong>W<sub>in</sub></strong> and <strong>W<sub>out</sub></strong> along both axes we both save memory and compute. Because we shard B along X, we reduce the size of the model-parallel AllGathers, and because we shard F along Y, we reduce the communication overhead of FSDP. This means a combination of the two can get us to an even lower effective batch size than we saw above.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/mixed-fsdp-model-parallelism-480.webp 480w,/scaling-book/assets/img/mixed-fsdp-model-parallelism-800.webp 800w,/scaling-book/assets/img/mixed-fsdp-model-parallelism-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/mixed-fsdp-model-parallelism.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> a diagram combining FSDP and tensor parallelism. Unlike the other cases, there is no duplication of model parameters.</figcaption> </figure> <details><summary>Here’s the full algorithm for mixed FSDP + tensor parallelism. While we have a lot of communication, all our AllGathers and ReduceScatters are smaller because we have batch-sharded our activations and tensor sharded our weights much more!</summary> <div class="algorithm"> <p><strong>Forward pass:</strong> need to compute Loss[B]</p> <ol> <li>In[B<sub>X</sub>, D] = <strong>AllGather</strong><sub>Y</sub>(In[B<sub>X</sub>, D<sub>Y</sub>]) <em>(on critical path)</em> </li> <li>W<sub>in</sub>[D, F<sub>Y</sub>] = <strong>AllGather</strong><sub>X</sub>(W<sub>in</sub>[D<sub>X</sub>, F<sub>Y</sub>]) <em>(can be done ahead of time)</em> </li> <li>Tmp[B<sub>X</sub>, F<sub>Y</sub>] = In[B<sub>X</sub>, D] *<sub>D</sub> W<sub>in</sub>[D, F<sub>Y</sub>]</li> <li>W<sub>out</sub>[F<sub>Y</sub>, D] = <strong>AllGather</strong><sub>X</sub>(W<sub>out</sub>[F<sub>Y</sub>, D<sub>X</sub>]) <em>(can be done ahead of time)</em> </li> <li>Out[B<sub>X</sub>, D] {U.Y} = Tmp[B<sub>X</sub>, F<sub>Y</sub>] *<sub>F</sub> W<sub>out</sub>[F<sub>Y</sub>, D]</li> <li>Out[B<sub>X</sub>, D<sub>Y</sub>] = <strong>ReduceScatter</strong><sub>Y</sub>(Out[B<sub>X</sub>, D] {U.Y}) <em>(on critical path)</em> </li> <li>Loss[B<sub>X</sub>] = …</li> </ol> <p><strong>Backward pass:</strong> need to compute dW<sub>out</sub>[F<sub>Y</sub>, D<sub>X</sub>], dW<sub>in</sub>[D<sub>X</sub>, F<sub>Y</sub>]</p> <ol> <li>dOut[B<sub>X</sub>, D<sub>Y</sub>] = …</li> <li>dOut[B<sub>X</sub>, D] = <strong>AllGather</strong><sub>Y</sub>(dOut[B<sub>X</sub>, D<sub>Y</sub>]) <em>(on critical path)</em> </li> <li>dW<sub>out</sub>[F<sub>Y</sub>, D] {U.X} = Tmp[B<sub>X</sub>, F<sub>Y</sub>] *<sub>B</sub> dOut[B<sub>X</sub>, D]</li> <li>dW<sub>out</sub>[F<sub>Y</sub>, D<sub>X</sub>] = <strong>ReduceScatter</strong><sub>X</sub>(dW<sub>out</sub>[F<sub>Y</sub>, D] {U.X})</li> <li>W<sub>out</sub>[F<sub>Y</sub>, D] = <strong>AllGather</strong><sub>X</sub>(W<sub>out</sub>[F<sub>Y</sub>, D<sub>X</sub>]) <em>(can be done ahead of time)</em> </li> <li>dTmp[B<sub>X</sub>, F<sub>Y</sub>] = dOut[B<sub>X</sub>, D] *<sub>D</sub> W<sub>out</sub>[F<sub>Y</sub>, D] <em>(can throw away dOut[B, D] here)</em> </li> <li>In[B<sub>X</sub>, D] = <strong>AllGather</strong><sub>Y</sub>(In[B<sub>X</sub>, D<sub>Y</sub>]) <em>(not on critical path + this can be shared with (2) from the previous layer)</em> </li> <li>dW<sub>in</sub>[D, F<sub>Y</sub>] {U.X} = dTmp[B<sub>X</sub>, F<sub>Y</sub>] *<sub>B</sub> In[B<sub>X</sub>, D]</li> <li>dW<sub>in</sub>[D<sub>X</sub>, F<sub>Y</sub>] = <strong>ReduceScatter</strong><sub>X</sub>(dW<sub>in</sub>[D, F<sub>Y</sub>] {U.X})</li> <li>W<sub>in</sub>[D, F<sub>Y</sub>] = <strong>AllGather</strong><sub>X</sub>(W<sub>in</sub>[D<sub>X</sub>, F<sub>Y</sub>]) <em>(can be done ahead of time)</em> </li> <li>dIn[B<sub>X</sub>, D] {U.Y} = dTmp[B<sub>X</sub>, F<sub>Y</sub>] *<sub>F</sub> W<sub>in</sub>[D, F<sub>Y</sub>] <em>(needed for previous layers)</em> </li> <li>dIn[B<sub>X</sub>, D<sub>Y</sub>] = <strong>ReduceScatter</strong><sub>Y</sub>(dIn[B<sub>X</sub>, D] {U.Y}) <em>(on critical path)</em> </li> </ol> </div> </details> <p><strong>What’s the right combination of FSDP and MP?</strong> A simple but key maxim is that FSDP moves weights and model parallelism moves activations. That means as our batch size shrinks (especially as we do more data parallelism), model parallelism becomes cheaper because our activations per-shard are smaller.</p> <ul> <li>Model parallelism performs \(\mathbf{AllGather}_Y([B_X, D_Y])\) which shrinks as \(X\) grows.</li> <li>FSDP performs \(\mathbf{AllGather}_X([D_X, F_Y])\) which shrinks as \(Y\) grows.</li> </ul> <p>Thus by combining both we can push our minimum batch size per replica down even more. We can calculate the optimal amount of FSDP and MP in the same way as above:</p> <p>Let \(X\) be the number of chips dedicated to FSDP and \(Y\) be the number of chips dedicated to tensor parallelism. Let \(N\) be the total number of chips in our slice with \(N=XY\). Let \(M_X\) and \(M_Y\) be the number of mesh axes over which we do FSDP and MP respectively (these should roughly sum to 3). We’ll purely model the forward pass since it has the most communication per FLOP. Then adding up the comms in the algorithm above, we have</p> \[T_\text{FSDP comms}(B, X, Y) = \frac{2\cdot 2\cdot D \cdot F}{Y \cdot W_\text{ici} \cdot M_X}\] \[T_\text{MP comms}(B, X, Y) = \frac{2 \cdot 2 \cdot B \cdot D}{X \cdot W_\text{ici} \cdot M_Y}\] <p>And likewise our total FLOPs time is</p> \[T_\text{math} = \frac{2\cdot 2 \cdot B \cdot D \cdot F}{N \cdot C}.\] <p>To simplify the analysis, we make two simplifications: first, we allow $X$ and $Y$ to take on non-integer values (as long as they are positive and satisfy $XY=N$); second, we assume that we do not overlap comms on the $X$ and $Y$ axis. Under the second assumption, the total comms time is</p> \[T_\text{comms} = T_\text{FSDP comms} + T_\text{MP comms}.\] <p>Before we ask under what conditions we’ll be compute-bound, let’s find the optimal values for $X$ and $Y$ to minimize our total communication. Since our FLOPs is independent of $X$ and $Y$, the optimal settings are those that simply minimize comms. To do this, let’s write $T_\text{comms}$ above in terms of $X$ and $N$ (which is held fixed, as it’s the number of chips in our system) rather than $X$ and $Y$:</p> \[T_\text{comms} (X) = \frac{F \cdot X}{N \cdot M_X} + \frac{B}{X \cdot M_Y}\] <p>Differentiating this expression wrt $X$ and setting the derivative equal to zero gives the optimal value $X_{opt}$:</p> \[\begin{align*} \frac{d}{dX} T_\text{comms} (X_{opt}) = \frac{F}{N \cdot M_X} - \frac{B}{X_{opt}^2 \cdot M_Y} \rightarrow \\ X_{opt} = \sqrt{\frac{B}{F} \frac{M_X}{M_Y} N} \end{align*}\] <p>This is super useful! This tells us, for a given $B$, $F$, and $N$, what amount of FSDP is optimal. Let’s get a sense of scale. Plugging in realistic values, namely $N = 64$ (corresponding to a 4x4x4 array of chips), $B=48,000$, $F=32,768$, gives roughly $X\approx 13.9$. So we would choose $X$ to be 16 and $Y$ to be 4, close to our calculated optimum.</p> <p class="takeaway"><strong>Takeaway:</strong> in general, during training, the optimal amount of FSDP is \(X_{opt} = \sqrt{\frac{B}{F} \frac{M_X}{M_Y} N}\). </p> <p>Now let’s return to the question we’ve been asking of all our parallelism strategies: <strong>under what conditions will we be compute-bound?</strong> Since we can overlap FLOPs and comms, we are compute-bound when</p> \[T_\text{FSDP comms} + T_\text{MP comms} &lt; T_\text{math}\] <p>which gives us</p> \[\frac{2\cdot 2\cdot D \cdot F}{Y \cdot W_\text{ici} \cdot M_X} + \frac{2 \cdot 2 \cdot B \cdot D}{X \cdot W_\text{ici} \cdot M_Y} &lt; \frac{2\cdot 2 \cdot B \cdot D \cdot F}{N \cdot C}\] <p>Letting $\alpha \equiv C / W_\text{ici}$, the ICI arithmetic intensity, we can simplify:</p> \[\frac{F}{Y \cdot M_X} + \frac{B}{X \cdot M_Y} &lt; \frac{B \cdot F}{N \cdot \alpha}\] <p>Plugging in our calculated $X_{opt}$ into the equation above (and noting that $Y_{opt} = N/X_{opt}$) results in the following condition on the batch size $B$:</p> \[\sqrt{\frac{4 \cdot B\cdot F}{M_X \cdot M_Y \cdot N}} &lt; \frac{B \cdot F}{N \cdot \alpha},\] <p>where the left-hand-side is proportional to the communication time and the right-hand-side is proportional to the computation time. Note that while the computation time scales linearly with the batch size (as it does regardless of parallelism), the communication time scales as the square root of the batch size. The ratio of the computation to communication time thus also scales as the square of the batch size:</p> \[\frac{T_\text{math}}{T_\text{comms}} = \frac{\sqrt{BF}\sqrt{M_X M_Y}}{2\alpha \sqrt{N}}.\] <p>To ensure that this ratio is greater than one so we are compute bound, we require</p> \[\frac{B}{N} &gt; \frac{4\alpha^2}{M_X M_Y F}\] <p>See Appendix C for an alternate derivation of this relation. To get approximate numbers, again plug in $F=32,768$, $\alpha=2550$, and $M_X M_Y=2$ (as it must be for a 3D mesh). This gives roughly $B/N &gt; 400$. This roughly wins us a factor of two compared to the purely data parallel (or FSDP) case, where assuming a 3D mesh we calculate that $B/N$ must exceed about $850$ to be compute bound.</p> <p class="takeaway"><strong>Takeaway:</strong> combining tensor parallelism with FSDP allows us to drop to a $B/N$ of \(2 \cdot 2550^2 / F\). This lets us handle a batch of as little as 400 per chip, which is roughly a factor of two smaller than we could achieve with just FSDP.</p> <p>Below we plot the ratio of FLOPs to comms time for mixed FSDP + MP, comparing it both to only model parallelism and only data parallelism (FSDP), on a representative 4x4x4 chip array. While pure FSDP parallelism dominates for very large batch sizes, in the regime where batch size over number of chips is between roughly 400 and 850, a mixed FSDP + MP strategy is required in order to be compute-bound.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/mixed-fsdp-comms-2-480.webp 480w,/scaling-book/assets/img/mixed-fsdp-comms-2-800.webp 800w,/scaling-book/assets/img/mixed-fsdp-comms-2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/mixed-fsdp-comms-2.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> ratio of FLOPs to comms time for optimal mixed FSDP/MP on a TPUv5p 4x4x4 slice with F=30k. As expected, model parallelism has a fixed ratio with batch size; ideal mixed FSDP + MP scales with $\sqrt{B}$, and FSDP scales with $B$. However, in intermediate batch size regimes, only FSDP + MP achieves a ratio greater than unity.</figcaption> </figure> <p>Here’s another example of TPU v5p 16x16x16 showing the FLOPs and comms time as a function of batch size for different sharding schemes.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/comms-flops-time-480.webp 480w,/scaling-book/assets/img/comms-flops-time-800.webp 800w,/scaling-book/assets/img/comms-flops-time-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/comms-flops-time.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> time taken for communication with different parallelism schemes. The black dashed line is the time taken by the matrix multiplication FLOPs, so any curve above this line is comms-bound. We note that all strategies become comms-bound below batch size 1.5e6, which is in line with our expected 4096 * 2 * 2550^2 / (8192 * 4) = 1.6e10.</figcaption> </figure> <p>The black curve is the amount of time spent on model FLOPs, meaning any batch size where this is lower than all comms costs is strictly comms bound. You’ll notice the black curve intersects the green curve at about <code class="language-plaintext highlighter-rouge">1.6e10</code>, as predicted.</p> <p>Zooming in, we can see that devoting two axes to FSDP, and using the optical switches to reconfigure the topology to have an 8-long axis for model sharding will give us the lowest communication volume between 1M and 6M batch size per slice, while pure FSDP combination is best between 6M and 100M. This agrees with our calculations above!</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/comms-flops-time-zoom-480.webp 480w,/scaling-book/assets/img/comms-flops-time-zoom-800.webp 800w,/scaling-book/assets/img/comms-flops-time-zoom-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/comms-flops-time-zoom.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Here’s an interactive animation to play with this, showing the total compute time and communication time for different batch sizes:</p> <div class="l-page"> <iframe src="/scaling-book/assets/plotly/training-roofline.html" frameborder="0" scrolling="no" height="400px" width="100%"></iframe> </div> <p>You’ll notice this generally agrees with the above (minimum around FSDP=256, MP=16), plus or minus some wiggle factor for some slight differences in the number of axes for each.</p> <h3 id="pipelining">Pipelining</h3> <p>You’ll probably notice we’ve avoided talking about pipelining at all in the previous sections. Pipelining is a dominant strategy for GPU parallelism that is somewhat less essential on TPUs. Briefly, pipelined training involves splitting the layers of a model across multiple devices and passing the activations between pipeline stages during the forward and backward pass. The algorithm is something like:</p> <ol> <li>Initialize your data on TPU 0 with your weights sharded across the layer dimension ($W_\text{in}[L_Z, D_X, F_Y]$ for pipelining with FSDP and tensor parallelism).</li> <li>Perform the first layer on TPU 0, then copy the resulting activations to TPU 1, and repeat until you get to the last TPU.</li> <li>Compute the loss function and its derivative $\partial L / \partial x_L$.</li> <li>For the last pipeline stage, compute the derivatives $\partial L / \partial W_L$ and $\partial L / \partial x_{L-1}$, then copy $\partial L / \partial x_{L-1}$ to the previous pipeline stage and repeat until you reach TPU 0.</li> </ol> <details><summary>Here is some (working) Python pseudo-code</summary> <p>This pseudocode should run on a Cloud TPU VM. While it’s not very efficient or realistic, it gives you a sense how data is being propagated across devices.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">d_model</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">d_ff</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">d_model</span>

<span class="n">num_layers</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">jax</span><span class="p">.</span><span class="nf">devices</span><span class="p">())</span>

<span class="n">key</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nc">PRNGKey</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Pretend each layer is just a single matmul.
</span><span class="n">x</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">normal</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">d_model</span><span class="p">))</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">normal</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">num_layers</span><span class="p">,</span> <span class="n">d_model</span><span class="p">,</span> <span class="n">d_model</span><span class="p">))</span> 

<span class="k">def</span> <span class="nf">layer_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">@</span> <span class="n">weight</span>

<span class="c1"># Assume we have num_layers == num_pipeline_stages
</span><span class="n">intermediates</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">num_layers</span><span class="p">):</span>
  <span class="n">x</span> <span class="o">=</span> <span class="nf">layer_fn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
  <span class="n">intermediates</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">num_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">device_put</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">jax</span><span class="p">.</span><span class="nf">devices</span><span class="p">()[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">loss_fn</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">jnp</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">batch</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># make up some fake loss function
</span>
<span class="n">loss</span><span class="p">,</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">value_and_grad</span><span class="p">(</span><span class="n">loss_fn</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_layers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
  <span class="n">_</span><span class="p">,</span> <span class="n">f_vjp</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">vjp</span><span class="p">(</span><span class="n">layer_fn</span><span class="p">,</span> <span class="n">intermediates</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
  <span class="n">dx</span><span class="p">,</span> <span class="n">dw</span> <span class="o">=</span> <span class="nf">f_vjp</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>  <span class="c1"># compute the jvp dx @ J(L)(x[i], W[i])
</span>  <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">dw</span>  <span class="c1"># update our weights
</span>
  <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">jax</span><span class="p">.</span><span class="nf">device_put</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">jax</span><span class="p">.</span><span class="nf">devices</span><span class="p">()[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> </details> <p><strong>Why is this a good idea?</strong> Pipelining is great for many reasons: it has a low communication cost between pipeline stages, meaning you can train very large models even with low bandwidth interconnects. This is often very useful on GPUs since they are not densely connected by ICI in the way TPUs are.</p> <p><strong>Why is this difficult/annoying?</strong> You might have noticed in the pseudocode above that TPU 0 is almost always idle! It’s only doing work on the very first and last step of the pipeline. The period of idleness is called a pipeline bubble and is very annoying to deal with. Typically we try to mitigate this first with microbatching, which sends multiple small batches through the pipeline, keeping TPU 0 utilized for at least a larger fraction of the total step time.</p> <p>A second approach is to carefully overlap the forward matmul $W_i @ x_i$, the backward $dx$ matmul $W_i @ \partial L / \partial x_{i+1}$, and the $dW$ matmul $\partial L / \partial x_{i+1} @ x_i$. Since each of these requires some FLOPs, we can overlap them to fully hide the bubble. Here’s a plot from the recent DeepSeek v3 paper<d-cite key="DeepSeek3"></d-cite> showing their “bubble-free” pipeline schedule:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/deepseek-pipeline-480.webp 480w,/scaling-book/assets/img/deepseek-pipeline-800.webp 800w,/scaling-book/assets/img/deepseek-pipeline-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/deepseek-pipeline.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> the DeepSeek v3 pipeline schedule (from their <a href="https://github.com/deepseek-ai/DeepSeek-V3/blob/main/DeepSeek_V3.pdf" rel="external nofollow noopener" target="_blank">recent paper</a>). Orange is the forward matmul, green is the dL/dx matmul, and blue is the dL/dW matmul. By prioritizing the backwards dL/dx multiplications, we can avoid "stranding" FLOPs.</figcaption> </figure> <p>Because it is less critical for TPUs (which have larger interconnected pods), we won’t delve into this as deeply, but it’s a good exercise to understand the key pipelining bottlenecks.</p> <h3 id="scaling-between-pods">Scaling Between Pods</h3> <p>Let’s take a step back and look at a specific example, say training LLaMA-3 70B on TPU v5p. LLaMA-3 70B has \(F\approx 30,000\). From the above sections, we know the following:</p> <ul> <li>We’ll be ICI bound when we do model parallelism greater than \(Y &gt; n_\text{axes} * F / 2550 \approxeq n_\text{axes} * 11\).</li> <li>Pure FSDP becomes ICI bound when we have a \(\text{batch size} &lt; 2550 / n_\text{axes}\). Here that means if we wanted to train with BS=2M, we’d at most be able to use $\approx 2400$ chips, which is roughly a quarter of a TPU v5p pod.</li> <li>Mixed FSDP + model parallelism becomes ICI bound when we have \(\text{batch size} &lt; 2 \cdot 2550^2 / 30,000 = 432\), so this lets us scale to roughly 9k chips! However, the maximum size of a TPU v5p pod is 8k chips, and beyond that we have to scale to lower-bandwidth data-center networking (DCN).</li> </ul> <p>So this gives us a nice recipe to fit on a single pod with BS=3.5M. We’d use the equation above, which gives roughly X (FSDP) = 1024 and Y (MP) = 8. If the model was larger, there would be room to expand the model sharding to 16. We have a bit of room to drop the batch size as low as BS=1.5M on that pod and still be compute bound, but we’re close to the lower bound there.</p> <p><strong>To go larger than one pod, we need to scale over DCN.</strong> Because DCN has lower bandwidth, it’s typically too slow to do much useful FSDP. Instead, we do pure data parallelism over the DCN axis and FSDP within a pod. Lets calculate whether the Data Center Network (DCN) holds up.</p> <p>With pure data parallelism over DCN, we need to sync the weights and optimizer states during each step (as the model completes its backward pass we need to complete the AllReduce). We can actually just borrow the math from the pure data parallelism section above which tells us that we become comms bound when the $\text{per pod batch size} &gt; C_\text{pod} / W_\text{dcn}$ where the RHS here is the total compute and total bandwidth for the entire pod.</p> <ul> <li>Our total DCN ingress+egress bandwidth is 2.5e10 per host, with 4 chips per host. This gives us ~2000 hosts in the slice, and a total of <code class="language-plaintext highlighter-rouge">5e13</code> bytes of bandwidth.</li> <li>\(C_\text{pod}\) here is the pod size times the per-chip compute, which is <code class="language-plaintext highlighter-rouge">8k * 4.5e14 = 3.8e18</code> FLOPs.</li> </ul> <p>As before, we become bottlenecked when $T_\text{math} &lt; T_\text{comms}$ which happens when our $\text{per pod batch size} &gt; C / W_\text{DCN} = 3.8e18 / 5e13 = 76,000$ (our pod level DCN operational intensity). For LLaMA-3, that’s not going to be a problem since our per-pod batch size is much higher than that, but it could become an issue if we were to train on smaller slices (e.g. v5e).</p> <p class="takeaway"><strong>Takeaway:</strong> This means we can scale fairly arbitrarily across pods, so e.g. with 10 pods of 8960 chips we could do a global batch size of about 40M tokens on 89,600 chips, training LLaMA-3 70B in about 2 days.</p> <h2 id="takeaways-from-llm-training-on-tpus">Takeaways from LLM Training on TPUs</h2> <ul> <li> <p>Increasing parallelism or reducing batch size both tend to make us more communication-bound because they reduce the amount of compute performed per chip.</p> </li> <li> <p>Up to a reasonable context length (~32k) we can get away with modeling a Transformer as a stack of MLP blocks and define each of several parallelism schemes by how they shard the two/three main matmuls per layer.</p> </li> <li> <p>During training there are 4 main parallelism schemes we consider, each of which has its own bandwidth and compute requirements (data parallelism, FSDP, model parallelism).</p> </li> </ul> <table> <thead> <tr> <th><strong>Strategy</strong></th> <th><strong>Description</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Data Parallelism</strong></td> <td>Activations are batch sharded, everything else is fully-replicated, we all-reduce gradients during the backward pass.</td> </tr> <tr> <td><strong>FSDP</strong></td> <td>Activations, weights, and optimizer are batch sharded, weights are gathered just before use, gradients are reduce-scattered.</td> </tr> <tr> <td><strong>Model Parallelism (aka Megatron, Tensor)</strong></td> <td>Activations are sharded along \(d_\text{model}\), weights are sharded along \(d_{ff}\), activations are gathered before W<sub>in</sub>, the result reduce-scattered after W<sub>out</sub>.</td> </tr> <tr> <td><strong>Mixed FSDP + Model Parallelism</strong></td> <td>Both of the above, where FSDP gathers the model sharded weights.</td> </tr> </tbody> </table> <p>And here are the “formulas” for each method:</p> \[\small \begin{array}{cc} \text{Strategy} &amp; \text{Formula}\\ \hline \text{DP} &amp; \text{In}[B_X, D] \cdot_D W_\text{in}[D, F] \cdot_F W_\text{out}[F, D] \rightarrow \text{Out}[B_X, D] \\ \text{FSDP} &amp; \text{In}[B_X, D] \cdot_D W_\text{in}[D_X, F] \cdot_F W_\text{out}[F, D_X] \rightarrow \text{Out}[B_X, D] \\ \text{MP} &amp; \text{In}[B, D_Y] \cdot_D W_\text{in}[D, F_Y] \cdot_F W_\text{out}[F_Y, D] \rightarrow \text{Out}[B, D_Y] \\ \text{MP + FSDP} &amp; \text{In}[B_X, D_Y] \cdot_D W_\text{in}[D_X, F_Y] \cdot_F W_\text{out}[F_Y, D_X] \rightarrow \text{Out}[B_X, D_Y] \\ \hline \end{array}\] <ul> <li>Each of these strategies has a limit at which it becomes network/communication bound, based on their per-device compute and comms. Here’s compute and comms per-layer, assuming \(X\) is FSDP and \(Y\) is model parallelism.</li> </ul> \[\small \begin{array}{ccc} \text{Strategy} &amp; \text{Compute per layer} &amp; \text{Comms per layer} \\ &amp; \text{(ignoring gating einsum)} &amp; \text{(bytes, forward + backward pass)}\\ \hline \text{DP} &amp; 4BDF/X + 8BDF/X &amp; 0 + 8DF \\ \text{FSDP} &amp; 4BDF/X + 8BDF/X &amp; 4DF + 8DF \\ \text{MP} &amp; 4BDF/Y + 8BDF/Y &amp; 4BD + 4BD \\ \text{FSDP + MP} &amp; 4BDF/(XY) + 8BDF/(XY) &amp; (4BD/X + 4DF/Y) + (8BD/X + 8DF/Y) \\ \hline \end{array}\] <ul> <li> <p>Pure data parallelism is rarely useful because the model and its optimizer state use bytes = 10x parameter count. This means we can rarely fit more than a few billion parameters in memory.</p> </li> <li> <p>Data parallelism and FSDP become comms bound when the \(\text{batch size per shard} &lt; C / W\), the arithmetic intensity of the network. For ICI this is 2,550 and for DCN this is 75,000. This can be increased with more parallel axes.</p> </li> <li> <p>Model parallelism becomes comms bound when \(\lvert Y\rvert &gt; F / 2550\). <strong>This is around 8-16 way for most models.</strong> This is independent of the batch size.</p> </li> <li> <p>Mixed FSDP + model parallelism allows us to drop the batch size to as low as \(2 \cdot 2550^2 / F \approx 400\). This is fairly close to the point (~200) where we become HBM bandwidth bound anyway.</p> </li> <li> <p>Data parallelism across pods requires a minimum batch size per pod of roughly 75,000 before becoming DCN-bound.</p> </li> <li> <p>Basically, if your batch sizes are big or your model is small, things are simple. You can either do data parallelism or FSDP + data parallelism across DCN. The middle section is where things get interesting.</p> </li> </ul> <h2 id="some-problems-to-work">Some Problems to Work</h2> <p>Let’s use LLaMA-2 13B as a basic model for this section. Here are some details:</p> <table> <thead> <tr> <th>hyperparam</th> <th>value</th> </tr> </thead> <tbody> <tr> <td>n_layers (L)</td> <td>40</td> </tr> <tr> <td>d_model (D)</td> <td>5,120</td> </tr> <tr> <td>ffw_multiplier (F / D)</td> <td>2.7</td> </tr> <tr> <td>n_heads (N)</td> <td>40</td> </tr> <tr> <td>n_kv_heads (K)</td> <td>40</td> </tr> <tr> <td>d_qkv (H)</td> <td>128</td> </tr> <tr> <td>n_embeddings (V)</td> <td>32,000</td> </tr> </tbody> </table> <p><strong>Question 1:</strong> How many parameters does LLaMA-2 13B have (I know that’s silly but do the math)? <em>Note that, as in <a href="../transformers">Transformer Math</a>, LLaMA-3 has 3 big FFW matrices, two up-projection and one down-projection. We ignored the two “gating” einsum matrices in this section, but they behave the same as W<sub>in</sub> in this section.</em></p> <details><summary>Click here for the answer.</summary> <ul> <li>FFW parameters: \(3LDF\) = <code class="language-plaintext highlighter-rouge">8.5e9</code> </li> <li>Attention parameters: \(4DNHL\) = <code class="language-plaintext highlighter-rouge">4.2e9</code> </li> <li>Vocabulary parameters: \(2VD\) = <code class="language-plaintext highlighter-rouge">0.3e9</code> </li> <li>Total: <code class="language-plaintext highlighter-rouge">8.5e9 + 4.2e9 + 0.39e9 = 13.1e9</code>, as expected!</li> </ul> </details> <p><strong>Question 2:</strong> Let’s assume we’re training with BS=16M tokens and using Adam. Ignoring parallelism for a moment, how much total memory is used by the model’s parameters, optimizer state, and activations? <em>Assume we store the parameters in bf16 and the optimizer state in fp32 and checkpoint activations three times per layer (after the three big matmuls).</em></p> <details><summary>Click here for the answer.</summary> <p>The total memory used for the parameters (bf16) and the two optimizer states (fp32, the first and second moment accumulators) is <code class="language-plaintext highlighter-rouge">(2 + 4 + 4) * 13e9 ~ 130GB</code>. The activations after the first two matmuls are shaped $BF$ and after the last one $BD$ (per the Transformer diagram above), so the total memory for bf16 is $2 \cdot L \cdot (BD + 2 * BF) = 2LB \cdot (D + 2F)$ or <code class="language-plaintext highlighter-rouge">2 * 40 * 16e6 * 5,120 * (1 + 2 * 2.7) ~ 4.2e13 = 42TB</code>, since <code class="language-plaintext highlighter-rouge">B=16e16</code>. All other activations are more or less negligible.</p> </details> <p><strong>Question 3:</strong> Assume we want to train with 32k sequence length and a total batch size of 3M tokens on a TPUv5p 16x16x16 slice. Assume we want to use bfloat16 weights and a float32 optimizer, as above.</p> <ol> <li>Can we use pure data parallelism? Why or why not?</li> <li>Can we use pure FSDP? Why or why not? With pure FSDP, how much memory will be used per device (assume we do gradient checkpointing only after the 3 big FFW matrices).</li> <li>Can we use mixed FSDP + model parallelism? Why or why not? If so, what should $X$ and $Y$ be? How much memory will be stored per device? Using only roofline FLOPs estimates and ignoring attention, how long will each training step take?</li> </ol> <details><summary>Click here for the answer.</summary> <p>First, let’s write down some numbers. With 32k sequence length and a 3M batch size, we have a sequence batch size of 96. On a TPU v5p 16x16x16 slice, we have <code class="language-plaintext highlighter-rouge">393TB</code> of HBM.</p> <ol> <li> <p>We can’t use pure data parallelism, because it replicates the parameters and optimizer states on each chip, which are already around 130GB (from Q2) which is more HBM than we have per-chip (96GB).</p> </li> <li> <p>Let’s start by looking purely at memory. Replacing BS=16M with 3M in Q2, we get <code class="language-plaintext highlighter-rouge">~7.86e12</code> total checkpoint activations, and with the 1.3e11 optimizer state this brings us to almost exactly 8e12 = 8TB. The TPUv5p slice has <code class="language-plaintext highlighter-rouge">393TB</code> of HBM in total, so we are safely under the HBM limit. Next let’s look at whether we’ll be comms or compute-bound. With 4096 chips and 3 axes of parallelism, we can do a minimum batch size of <code class="language-plaintext highlighter-rouge">850 * 4096 = 3.48M</code> tokens. That’s slightly above our 3M batch size. So we’re actually comms-bound, which is sad. So the general answer is <strong>no, we cannot do FSDP alone</strong>.</p> </li> <li> <p>Now we know our primary concern is being comms-bound, so let’s plug in some numbers. First of all, from the discriminant above, we know our per-chip batch size with mixed FSDP + model parallelism needs to be above $2 \cdot 2550^2 / F = 940$ here, which is actually slightly worse than pure FSDP. Obviously that’s sort of an artifact of some of the approximations we made, but this suggests mixed FSDP + model parallelism isn’t actually much better. Partly this is because $F$ is so small we can’t do a full axis worth of model parallelism. One way around this is to do small subrings of 4 chips of tensor parallelism and dedicate the remaining bandwidth of the first axis to FSDP. We won’t do the math out but it’s good to check that we probably can do this without being comms-bound.</p> </li> </ol> </details> <p><strong>Question 4:</strong> What if we wanted to drop to batch size 1M? How does this affect the answers to question 3? What about batch size 10M?</p> <h3 class="next-section">That’s it for Part 5! For Part 6, which applies this content to real LLaMA models, <a href="../applied-training">click here</a>!</h3> <h2 id="appendix">Appendix</h2> <h3 id="appendix-a---more-stuff-about-fsdp">Appendix A - More stuff about FSDP</h3> <p>Here’s a nice extra figure showing how FSDP shards parameters/gradients. The rows are, in order, pure data parallelism, ZeRO-1/2/3. There’s not much reason not to do ZeRO-3 since it has effectively the same communication load.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/fsdp-figure-480.webp 480w,/scaling-book/assets/img/fsdp-figure-800.webp 800w,/scaling-book/assets/img/fsdp-figure-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/fsdp-figure.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Figure:</strong> diagram showing parameter, gradient, and optimizer state memory for pure data parallelism, ZeRO-1/2/3 respectively. <a href="https://arxiv.org/abs/1910.02054" rel="external nofollow noopener" target="_blank">Source</a>.</p> <h3 id="appendix-b---deriving-the-comms-necessary-for-the-backward-passes">Appendix B - Deriving the comms necessary for the backward passes</h3> <p>Above, we simplified the Transformer layer forward pass as Out[B, D] = In[B, D] *D W<sub>in</sub>[D, F] *<sub>F</sub> W<sub>out</sub>[F, D] . How do we derive the comms necessary for the backwards pass?</p> <p>This follows fairly naturally from the rule in the previous section for a single matmul <strong>Y = X * A</strong>:</p> \[\frac{dL}{dA} = \frac{dL}{dY}\frac{dY}{dA} = X^T \left(\frac{dL}{dY}\right)\] \[\frac{dL}{dX} = \frac{dL}{dY}\frac{dY}{dX} = \left(\frac{dL}{dY}\right) A^T\] <p>Using this, we get the following formulas (letting Tmp[B, F] stand for In[B, D] * W<sub>in</sub>[D, F]):</p> <div class="algorithm"> <ol> <li>dW<sub>out</sub>[F, D] = Tmp[B, F] *<sub>B</sub> dOut[B, D]</li> <li>dTmp[B, F] = dOut[B, D] *<sub>D</sub> W<sub>out</sub>[F, D]</li> <li>dW<sub>in</sub> = dTmp[B, F] *<sub>B</sub> Tmp[B, F]</li> <li>dIn[B, D] = dTmp[B, F] *<sub>F</sub> W<sub>in</sub>[D, F]</li> </ol> </div> <p>Note that these formulas are mathematical statements, with no mention of sharding. The job of the backwards pass is to compute these four quantities. So to figure out the comms necessary, we just take the shardings of all the quantities which are to be matmulled in the four equations above (Tmp, dOut, W<sub>out</sub>, W<sub>in</sub>), which are specified by our parallelization scheme, and use the rules of sharded matmuls to figure out what comms we have to do. Note that dOut is sharded in the same way as Out.</p> <h3 id="appendix-c---alternate-derivation-of-the-batch-size-constraint-for-mixed-fsdp--model-parallelism">Appendix C - Alternate derivation of the batch size constraint for mixed FSDP + model parallelism</h3> <p>Above we derived that when using a combination of FSDP + model parallelism, we can be compute-bound when</p> \[\frac{B}{N} &gt; \frac{4\alpha^2}{M_X M_Y F}\] <p>Here we present an alternate derivation of this fact. We start by setting the communication time equal to the computation time, and look for a condition which makes this equality impossible.</p> \[\frac{F}{Y \cdot M_X} + \frac{B}{X \cdot M_Y} = \frac{B \cdot F}{N \cdot \alpha}\] <p>Since $XY=N$, we can rewrite in terms of $X$:</p> <p>\(\frac{FX}{N \cdot M_X} + \frac{B}{X \cdot M_Y} = \frac{B \cdot F}{N \cdot \alpha}\), or</p> \[X^2 \frac{F}{N \cdot M_X} + \frac{B}{M_Y} - X \frac{B \cdot F}{N \cdot \alpha} = 0.\] <p>As this is a quadratic in $X$, the point at which we’ll have no solutions is the point at which the discriminant becomes zero. This occurs when</p> \[B^2\cdot F^2 \cdot M_X^2 \cdot M_Y^2 - 4\cdot \alpha^2 \cdot F \cdot B \cdot N \cdot M_Y \cdot M_X = 0\] <p>or by simplifying</p> \[B\cdot F \cdot M_X \cdot M_Y - 4\cdot \alpha^2 \cdot N = 0\] <p>which gives us</p> \[B = \frac{4 \cdot \alpha^2 \cdot N}{F \cdot M_X \cdot M_Y}\] <p>so our total batch size divided by the total number of chips cannot drop below</p> \[\frac{4 \alpha^2}{F \cdot M_X \cdot M_Y},\] <p>as we had derived above.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> <div class="base-grid appendix-entry"> <h3 style="grid-column: 0;">Miscellaneous</h3> <p class="author-footnote" style="grid-column: text;"><sup>*</sup>Work done at Google DeepMind, now at MatX.</p> </div> <div class="base-grid appendix-entry"> <h3 style="grid-column: 0;">Citation</h3> <p class="author-footnote">For attribution in academic contexts, please cite this work as:</p> <div class="author-footnote"> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">Austin et al., "How to Scale Your Model", Google DeepMind, online, 2025.</span>
</code></pre></div></div> </div> <p class="author-footnote">or as a BibTeX entry:</p> <div class="author-footnote"> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">@article</span><span class="p">{</span><span class="nl">scaling-book</span><span class="p">,</span>
      <span class="na">title</span> <span class="p">=</span> <span class="s">{How to Scale Your Model}</span><span class="p">,</span>
      <span class="na">author</span> <span class="p">=</span> <span class="s">{Austin, Jacob and Douglas, Sholto and Frostig, Roy and Levskaya, Anselm and Chen, Charlie and Vikram, Sharad
      and Lebron, Federico and Choy, Peter and Ramasesh, Vinay and Webson, Albert and Pope, Reiner}</span><span class="p">,</span>
      <span class="na">publisher</span> <span class="p">=</span> <span class="s">{Google DeepMind}</span><span class="p">,</span>
      <span class="na">howpublished</span> <span class="p">=</span> <span class="s">{Online}</span><span class="p">,</span>
      <span class="na">note</span> <span class="p">=</span> <span class="s">{Retrieved from https://jax-ml.github.io/scaling-book/}</span><span class="p">,</span>
      <span class="na">year</span> <span class="p">=</span> <span class="s">{2025}</span>
    <span class="p">}</span>
</code></pre></div></div> </div> </div> </d-appendix> <d-bibliography src="/scaling-book/assets/bibliography/main.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'jax-ml/scaling-book',
        'data-repo-id': '',
        'data-category': 'General',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '0',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-loading': '1',
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/scaling-book/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/scaling-book/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/scaling-book/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/scaling-book/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/scaling-book/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/scaling-book/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/scaling-book/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/scaling-book/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/scaling-book/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> </body> </html>