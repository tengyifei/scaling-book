<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> All the Transformer Math You Need to Know | How To Scale Your Model </title> <meta name="author" content=" "> <meta name="description" content="Here we'll do a quick review of the Transformer architecture, specifically how to calculate FLOPs, bytes, and other quantities of interest."> <meta name="keywords" content="scaling, jax, llms, transformers, tpus, google, deepmind, parallelism, pallas"> <link rel="stylesheet" href="/scaling-book/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/scaling-book/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/scaling-book/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/scaling-book/assets/css/jekyll-pygments-themes-vs.css?4ee1a2facd1a8a76347f4bd43a740500" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/scaling-book/assets/img/favicon.png?fddbd8c2ec231ba2060e67c85de32a55"> <link rel="stylesheet" href="/scaling-book/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jax-ml.github.io/scaling-book/transformers/"> <script src="/scaling-book/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/scaling-book/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script src="/scaling-book/assets/js/distillpub/template.v2.js"></script> <script src="/scaling-book/assets/js/distillpub/transforms.v2.js"></script> <style type="text/css">{{page._styles}}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "All the Transformer Math You Need to Know",
            "description": "Here we'll do a quick review of the Transformer architecture, specifically how to calculate FLOPs, bytes, and other quantities of interest.",
            "published": "February 04, 2025",
            "authors": [
              
              {
                "author": "Jacob Austin",
                "authorURL": "https://www.jacobaustin.org/",
                "affiliations": [
                  {
                    "name": "Google DeepMind",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Sholto Douglas",
                "authorURL": "https://x.com/_sholtodouglas",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Roy Frostig",
                "authorURL": "https://cs.stanford.edu/~rfrostig/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Anselm Levskaya",
                "authorURL": "https://anselmlevskaya.com/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Charlie Chen",
                "authorURL": "https://x.com/charliexychen",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Sharad Vikram",
                "authorURL": "https://sharadvikram.com/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Federico Lebron",
                "authorURL": "https://fedelebron.com/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Peter Choy",
                "authorURL": "https://x.com/pchoy95",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Vinay Ramasesh",
                "authorURL": "https://x.com/vinayramasesh",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Albert Webson",
                "authorURL": "https://representation.ai/",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Reiner Pope<sup>*</sup>",
                "authorURL": "https://x.com/reinerpope",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <script>
    function goToTop() {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }

    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function() {scrollFunction()};

    function scrollFunction() {
      // Get the button:
      let mybutton = document.getElementById("top-button");

      if (document.body.scrollTop > 40 || document.documentElement.scrollTop > 40) {
        mybutton.style.display = "block";
      } else {
        mybutton.style.display = "none";
      }
  }
  </script> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/scaling-book"> How To Scale Your Model </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="left-button section-button"><a href="../sharding"><svg viewbox="-78.5 0 512 512"><path d="M257 64L291 98 128 262 291 426 257 460 61 262 257 64Z"></path></svg></a></div> <div class="right-button section-button"><a href="../training"><svg viewbox="-78.5 0 512 512"><path d="M98 460L64 426 227 262 64 98 98 64 294 262 98 460Z"></path></svg></a></div> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/scaling-book/"> </a> </li> <li class="nav-item nav-hidden"><a class="nav-link" onclick="goToTop()" id="top-button" style="display: none;">Back to Top</a></li> <li class="nav-item nav-hidden"><p class="nav-link"></p></li> <li class="nav-item nav-hidden"><a class="nav-link" href="../sharding">Previous Part</a></li> <li class="nav-item nav-hidden"><a class="nav-link" href="../training">Next Part</a></li> <li class="nav-item nav-hidden"><p class="nav-link"></p></li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Sections </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/scaling-book/index">Part 0. Introduction</a> <a class="dropdown-item " href="/scaling-book/roofline">Part 1. Intro to Rooflines</a> <a class="dropdown-item " href="/scaling-book/tpus">Part 2. All About TPUs</a> <a class="dropdown-item " href="/scaling-book/sharding">Part 3. Sharded Matmuls</a> <a class="dropdown-item " href="/scaling-book/transformers">Part 4. Transformers</a> <a class="dropdown-item " href="/scaling-book/training">Part 5. Training</a> <a class="dropdown-item " href="/scaling-book/applied-training">Part 6. Training LLaMA</a> <a class="dropdown-item " href="/scaling-book/inference">Part 7. Inference</a> <a class="dropdown-item " href="/scaling-book/applied-inference">Part 8. Serving LLaMA</a> <a class="dropdown-item " href="/scaling-book/profiling">Part 9. Profiling</a> <a class="dropdown-item " href="/scaling-book/jax-stuff">Part 10. All About JAX</a> <a class="dropdown-item " href="/scaling-book/conclusion">Part 11. Conclusions</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>All the Transformer Math You Need to Know</h1> <p>Part 4 of <a href="/scaling-book">How To Scale Your Model</a> (<a href="../sharding">Part 3: Sharding</a> | <a href="../training">Part 5: Training</a>)</p> <p>Here we'll do a quick review of the Transformer architecture, specifically how to calculate FLOPs, bytes, and other quantities of interest.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#counting-dots">Counting Dots</a> </div> <div> <a href="#"></a> </div> <ul> <li> <a href="#forward-and-reverse-flops">Forward and reverse FLOPs</a> </li> </ul> <div> <a href="#transformer-accounting">Transformer Accounting</a> </div> <div> <a href="#global-flops-and-params-calculation">Global FLOPs and Params Calculation</a> </div> <div> <a href="#miscellaneous-math">Miscellaneous Math</a> </div> <div> <a href="#"></a> </div> <ul> <li> <a href="#sparsity-and-mixture-of-experts">Sparsity and Mixture-of-Experts</a> </li> <li> <a href="#gradient-checkpointing">Gradient checkpointing</a> </li> <li> <a href="#key-value-kv-caching">Key-Value (KV) caching</a> </li> </ul> <div> <a href="#what-should-you-take-away-from-this-section">What Should You Take Away from this Section?</a> </div> <div> <a href="#a-few-problems-to-work">A Few Problems to Work</a> </div> <div> <a href="#appendix">Appendix</a> </div> <div> <a href="#"></a> </div> <ul> <li> <a href="#appendix-a-how-does-flash-attention-work">Appendix A: How does Flash Attention work?</a> </li> </ul> </nav> </d-contents> <h2 id="counting-dots">Counting Dots</h2> <p>Let’s start with vectors \(x\),\(y\) and matrices \(A\),\(B\) of the following shapes:</p> \[\def \red#1{\textcolor{red}{#1}} \def \green#1{\textcolor{green}{#1}} \def \blue#1{\textcolor{blue}{#1}} \def \purple#1{\textcolor{purple}{#1}} \def \orange#1{\textcolor{orange}{#1}} \def \gray#1{\textcolor{gray}{#1}} \begin{array}{cc} \textrm{array} &amp; \textrm{shape} \\ \hline x &amp; \textrm{[P]} \\ y &amp; \textrm{[P]} \\ A &amp; \textrm{[N P]} \\ B &amp; \textrm{[P M]} \\ \hline \end {array}\] <ul> <li>A dot product of \(x \cdot y\) requires \(P\) <em>adds</em> and <em>multiplies</em>, or \(2P\) floating-point operations total.</li> <li>A matrix-vector product \(Ax\) does \(N\) dot-products along the rows of \(A\), for \(2NP\) FLOPs.</li> <li>A matrix-matrix product \(AB\) does \(M\) matrix-vector products for each column of \(B\), for \(2NPM\) FLOPs total.</li> <li>In general, if we have two higher dimensional arrays \(C\) and \(D\), where some dimensions are <span style="color:red">CONTRACTING</span> and some are <span style="color:blue">BATCHING</span>. (e.g. \(C[\blue{GH}IJ\red{KL}], D[\blue{GH}MN\red{KL}]\)) then the FLOPs cost of this contraction is two times the product of all of the \(C\) and \(D\) dimensions where the batch and contraction dimensions are only counted once, (e.g. \(2\blue{GH}IJMN\red{KL}\)). Note that a dimension is only batching if it occurs in both multiplicands. (Note also that the factor of 2 won’t apply if there are no contracting dimensions and this is just an elementwise product.)</li> </ul> \[\begin{array}{ccc} \textrm{Operation} &amp; \textrm{FLOPs} &amp; \textrm{Data} \\ \hline x \cdot y &amp; 2P &amp; 2P \\ A x &amp; 2NP &amp; NP + P \\ AB &amp; 2NPM &amp; NP + PM \\ [c_0,...,c_N] \cdot [d_0,...,d_N] &amp; 2 \prod c_i \times \prod_{\substack{d_j \notin \blue{BATCH} \\ d_j \notin \red{CONTRACT}}} d_j &amp; \prod c_i + \prod d_j \\ \hline \end {array}\] <p>Make note of the fact that for a matrix-matrix multiply, the <em>compute</em> scales cubically \(O(N^3)\) while the data transfer only scales quadratically \(O(N^2)\) - this means that as we scale up our matmul size, it becomes <em>easier</em> to hit the compute-saturated limit. This is extremely unusual, and explains in large part why we use architectures dominated by matrix multiplication - they’re amenable to being scaled!</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/matmul-flops-480.webp 480w,/scaling-book/assets/img/matmul-flops-800.webp 800w,/scaling-book/assets/img/matmul-flops-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/matmul-flops.gif" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h3 id="forward-and-reverse-flops">Forward and reverse FLOPs</h3> <p>During training, we don’t particularly care about the result of a given matrix multiply; we really care about its derivative. That means we do significantly more FLOPs during backpropagation.</p> <p>If we imagine <strong>B</strong> is just one matrix in a larger network and <strong>A</strong> are our input activations with <strong>C = A B</strong>, the derivative of the loss <strong>L</strong> with respect to <strong>B</strong> is given by the chain rule:</p> \[\frac{\partial L}{\partial B} = \frac{\partial L}{\partial C}\frac{\partial C}{\partial B} = A^T \left(\frac{\partial L}{\partial C}\right)\] <p>which is an outer product and requires $2NPM$ FLOPs to compute (since it contracts over the $N$ dimension). Likewise, the derivative of the loss with respect to <strong>A</strong> is</p> \[\frac{\partial L}{\partial A} = \frac{\partial L}{\partial C}\frac{\partial C}{\partial A} = \left(\frac{\partial L}{\partial C}\right) B^T\] <p>is again $2NPM$ FLOPs since <strong>dL/dC</strong> is a (co-)vector of size \([N, M]\). While this quantity isn’t the derivative wrt. a parameter, it’s used to compute derivatives for previous layers of the network (e.g. just as dL/dC is used to compute dL/dB above).</p> <p>Adding these up, we see that <strong>during training, we have a total of 6NPM FLOPs</strong>, compared to 2NPM during inference: 2NPM in the forward pass, 4NPM in the backward pass. Since PM is the number of parameters in the matrix, this is the simplest form of the famous \(6 * \text{num parameters} * \text{num tokens}\) approximation of Transformer FLOPs during training: each token requires \(6 * \text{num parameters}\) FLOPs. We’ll show a more correct derivation below.</p> <h2 id="transformer-accounting">Transformer Accounting</h2> <p>Transformers are the future. Well, they’re the present at least. Maybe a few years ago, they were one of many architectures. But today, it’s worth knowing pretty much every detail of the architecture. We won’t reintroduce the architecture but <a href="https://jalammar.github.io/illustrated-transformer/" rel="external nofollow noopener" target="_blank">this blog</a> and the <a href="https://arxiv.org/abs/1706.03762" rel="external nofollow noopener" target="_blank">original Transformer paper</a> may be helpful references.</p> <p>Here’s a basic diagram of the Transformer decoder architecture:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/transformer-diagram-480.webp 480w,/scaling-book/assets/img/transformer-diagram-800.webp 800w,/scaling-book/assets/img/transformer-diagram-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/transformer-diagram.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> this diagram shows one layer of a standard Transformer and flows from top-to-bottom. We use a single-letter convention to describe the shapes and layouts of arrays in a Transformer, again showing contracting dimensions in red, and batched dimensions in blue. In a given operation, the input shape is given on top-left and the parameter shape is given on the top-right, with the resulting shape below, e.g. BTD is the input shape for the gating einsum and DF is the weight shape.</figcaption> </figure> <p><strong>Note [gating einsum]</strong>: The diagram above uses a “<a href="https://arxiv.org/abs/2002.05202" rel="external nofollow noopener" target="_blank">gating einsums</a>”<d-cite key="glu"></d-cite> where we split the up-projection matrix into two matrices ($W_\text{In1}$ and $W_\text{In2}$ above) whose outputs are elementwise multiplied as a kind of “gating function”. Not all LLMs use this, so you will sometimes see a single $W_\text{In}$ matrix and a total MLP parameter count of 2DF instead of 3DF. Typically in this case, D and F will be scaled up to keep the parameter count the same as the 3 matrix case. With that said, some form of gating einsum is used by LLAMA, DeepSeek, and many other models.</p> <p><strong>Note 2 [MHA attention]</strong>: With self-attention, T and S are the same but for cross-attention they may be different. With vanilla Multi-Head Attention (MHA), N and K are the same while for <a href="https://arxiv.org/abs/1911.02150" rel="external nofollow noopener" target="_blank">Multi-Query Attention</a> (MQA)<d-cite key="mqa"></d-cite> K=1 and for <a href="https://arxiv.org/abs/2305.13245" rel="external nofollow noopener" target="_blank">Grouped MQA</a> (GMQA)<d-cite key="gmqa"></d-cite> K merely has to divide N.</p> <h2 id="global-flops-and-params-calculation">Global FLOPs and Params Calculation</h2> <p>For the below we’re going to compute per-layer FLOPs to avoid having to stick factors of <strong>L</strong> everywhere.</p> <h3 id="mlps">MLPs</h3> <p>The MLPs of a Transformer typically consist of 2 input matmuls that are element-wise combined and a single output matmul:</p> \[\begin{array}{ccc} \textrm{operation} &amp; \textrm{train FLOPs} &amp; \textrm{params} \\ \hline \\ A[B,T,\red{D}] \cdot W_{in1}[\red{D}, F] &amp; 6BTDF &amp; DF \\[10pt] A[B,T,\red{D}] \cdot W_{in2}[\red{D}, F] &amp; 6BTDF &amp; DF \\[10pt] \sigma\left(A_{in1}\right)[B,T, F] * A_{in2}[B,T, F] &amp; \gray{O(BTF)} \\[10pt] A[B,T,\red{F}] \cdot W_{out}[\red{F}, D] &amp; 6BTDF &amp; DF \\[10pt] \hline \\ &amp; \approx 18BTDF &amp; 3DF \end{array}\] <h3 id="attention">Attention</h3> <p>For multi-headed attention, let us assume equal head dimension H for <strong>Q</strong>,<strong>K</strong>,<strong>V</strong> projections, and estimate the cost of the <strong>QKVO</strong> matmuls:</p> \[\begin{array}{ccc} \textrm{operation} &amp; \textrm{train FLOPs} &amp; \textrm{params} \\ \hline \\ A[B,T,\red{D}] \cdot W_{Q}[\red{D}, N, H] &amp; 6BTDNH &amp; DNH \\[10pt] A[B,T,\red{D}] \cdot W_{K}[\red{D}, N, H] &amp; 6BTDNH &amp; DNH \\[10pt] A[B,T,\red{D}] \cdot W_{V}[\red{D}, N, H] &amp; 6BTDNH &amp; DNH \\[10pt] A[B,T,\red{N}, \red{H}] \cdot W_{O}[\red{N}, \red{H}, D] &amp; 6BTDNH &amp; DNH \\[10pt] \hline \\ &amp; 24BTDNH &amp; 4DNH \end{array}\] <p>The dot-product attention operation is more subtle, effectively being a \(TH \cdot HS\) matmul batched over the \(B\), \(N\) dimensions, a softmax, and a \(TS \cdot SH\) matmul again batched over the \(B\), \(N\) dimensions. We highlight the batched dims in blue:</p> \[\begin{array}{cc} \textrm{operation} &amp; \textrm{train FLOPs} \\ \hline \\[3pt] Q[\blue{B}, T, \blue{N}, \red{H}] \cdot K[\blue{B}, S, \blue{N}, \red{H}] &amp; 6BTSNH \\[3pt] \textrm{softmax}_S \;\; L[\blue{B}, T, S, \blue{N}] &amp; \gray{O(BTSN)} \\[3pt] S[\blue{B}, T, \red{S}, \blue{N}] \cdot V[\blue{B}, \red{S}, \blue{N}, H] &amp; 6BTSNH \\[3pt] \hline \\ &amp; \approx 12BTSNH = 12BT^2NH \\ \end{array}\] <h3 id="other-operations">Other Operations</h3> <p>There are several other operations happening in a Transformer. Layernorms are comparatively cheap and can be ignored for first-order cost estimates. There is also the final enormous (though not per-layer) unembedding matrix multiply.</p> \[\begin{array}{ccc} \textsf{operation} &amp; \textsf{train FLOPs} &amp; \textsf{params} \\ \hline \\ \textrm{layernorm}_D \;\; A[B,T,\red{D}] &amp; \gray{O\left(BTD\right)} &amp; \gray{D} \\[10pt] A[B,T,\red{D}] \cdot W_{unembed}[\red{D}, V] &amp; 6BTDV &amp; DV \\ \end{array}\] <h3 id="general-rule-of-thumb-for-transformer-flops">General rule of thumb for Transformer FLOPs</h3> <p>If we neglect the cost of dot-product attention for shorter-context training, then the total FLOPs across all layers is</p> \[\begin{align*} 18BTDF + 24BTDNH = 6 *BT * (3DF + 4DNH) \\ = 6 * \textrm{num tokens} * \textrm{parameter count} \end{align*}\] <p>Leading to a famous rule of thumb for estimating Transformer FLOP count, ignoring the attention FLOPs. (Unembedding is another simple matmul with $6BSEV$ FLOPs and $EV$ params, and follows the same rule of thumb.)</p> <h3 id="fractional-cost-of-attention-with-context-length">Fractional cost of attention with context length</h3> <p>If we do account for dot-product attention above and assume \(F=4D\) and \(D=NH\) (as is typical):</p> \[\small{\frac{\textrm{attention FLOPs}}{\textrm{matmul FLOPs}} = \frac{12BT^2NH}{18BTDF + 24BTDNH} = \frac{12BT^2D}{4*18 BTD^2 + 24 BTD^2} = \frac{12BT^2D}{96 BTD^2} = \frac{T}{8D}}\] <p>So the takeaway is that <strong>dot-product attention FLOPs only become dominant during training once T&gt;8D</strong>. For D ~ 8k, this would be ~64K tokens. This makes some sense, since it means as the MLP size increases, the attention FLOPs become less critical. For large models, the quadratic cost of attention is not actually a huge obstacle to longer context training. However, for smaller models, even e.g. Gemma-27B, D=4608 which means attention becomes dominant around 32k sequence lengths. Flash Attention also helps alleviate the cost of long-context, which we discuss briefly <a href="#appendix-a-how-does-flash-attention-work">in Appendix A</a>.</p> <h2 id="miscellaneous-math">Miscellaneous Math</h2> <h3 id="sparsity-and-mixture-of-experts">Sparsity and Mixture-of-Experts</h3> <p>We’d be remiss not to briefly discuss Mixture of Experts (MoE) models<d-cite key="moe"></d-cite>, which replace the single dense MLP blocks in a standard Transformer with a set of independent MLPs that can be dynamically routed between. To a first approximation, <strong>an MoE is just a normal dense model with E MLP blocks per layer</strong>, instead of just one. Each token activates $k$ of these experts, typically $k=2$. This increases the parameter count by $O(E)$, while multiplying the total number of activated parameters per token by $k$, compared with the dense version.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/moe-480.webp 480w,/scaling-book/assets/img/moe-800.webp 800w,/scaling-book/assets/img/moe-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/moe.png" class="img-fluid img-small" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> <figcaption class="caption"><b>Figure:</b> an example MoE layer with $n$ experts. The gating expert routes each token to $k$ of them, and the output of those $k$ MLPs get summed. Our parameter count is $n$ times the size of each expert, but only $k$ are used for each token. <a href="https://deepgram.com/learn/mixture-of-experts-ml-model-guide" rel="external nofollow noopener" target="_blank">Source</a>.</figcaption> </figure> <p>Compared to a dense model, an MoE introduces new comms, primarily two AllToAlls (one before and one after the MoE block) that route tokens to the correct expert and bring them back to their home device.<d-footnote>Technically, this only happens if we are data or sequence sharded along the same axis as our experts.</d-footnote> However as we saw in the previous section, the cost of each AllToAll is only 1/4 that of a comparable AllGather along a single axis (for a bidirectional ring).</p> <h3 id="gradient-checkpointing">Gradient checkpointing</h3> <p>Backpropagation as an algorithm trades memory for compute. Instead of a backward pass requiring \(O(n_\text{layers}^2)\) FLOPs, <strong>it requires \(O(n_\text{layers})\) memory</strong>, saving all intermediate activations generated during the forward pass. While this is better than quadratic compute, it’s incredibly expensive memory-wise: a model with \(B * T=4M\) (4M total tokens per batch), L=64, and D=8192 that avoids all unnecessary backward pass compute would have to save roughly \(2 * 20 * B * T * D * L = 84TB\) of activations in bfloat16. 20 comes from (roughly) counting every intermediate node in the Transformer diagram above, since e.g.</p> \[f(x) = \exp(g(x))\] \[\frac{df}{dx} = \exp(g(x)) \cdot \frac{dg}{dx}\] <p>so to avoid recomputing we need to save \(g(x)\) and \(\exp(g(x))\) from the forward pass. To avoid saving this much memory, we can choose to only save some fraction of the intermediate activations. Here are a few strategies we use.</p> <ul> <li> <strong>Block remat</strong>: only save the input to each layer. This is the most aggressive method we use and only saves 1 checkpoint per layer, meaning we’d only save 4.2TB in the example above. This forces us to repeat essentially all forward pass FLOPs in the backward pass, meaning we increase our FLOPs from \(6ND\) to roughly \(8ND\).</li> <li> <strong>Big matmuls only:</strong> another simple policy is to only save the outputs of large matmuls. This lets us avoid recomputing any large matmuls during the backward pass, but still makes us recompute other activation functions and parts of attention. This reduces 20 per layer to closer to 7 per layer.</li> </ul> <p>This by no means comprehensive. When using JAX, these are typically controlled by <code class="language-plaintext highlighter-rouge">jax.remat</code>/<code class="language-plaintext highlighter-rouge">jax.checkpoint</code> (you can read more <a href="https://jax.readthedocs.io/en/latest/_autosummary/jax.checkpoint.html" rel="external nofollow noopener" target="_blank">here</a>).</p> <h3 id="key-value-kv-caching">Key-Value (KV) caching</h3> <p>As we’ll see in <a href="../inference">Section 7</a>, LLM inference has two key parts, prefill and generation.</p> <ul> <li> <strong>Prefill</strong> processes a long prompt and saves its attention activations in a Key-Value Cache (KV Cache) for use in generation, specifically the key-value projections in the attention block.</li> <li> <strong>Generation</strong> batches several of these KV caches together and samples tokens from each of them.</li> </ul> <p>Each KV cache is then effectively an array of size $[2, S, L, K, H]$ where the 2 accounts for the keys and values. This is quite large! The total size of the Key-Value cache in int8 is $2SLKH$. For a moderately-sized model with 8k context length, 64 layers, and $KH = NH = D = 8192$, this is $2 \cdot 8192 \cdot 64 \cdot 8192 = 8\text{GiB}$. You can see why we would want to use GMQA with $K \ll N$.</p> <h2 id="what-should-you-take-away-from-this-section">What Should You Take Away from this Section?</h2> <ul> <li>The overall parameters and FLOPs of a Transformer are fairly easy to calculate, and are summarized here, assuming MHA (with batch size B, vocab size V, a sequence of length T, D=d<sub>model</sub>, and F=d<sub>ff</sub>):</li> </ul> <table> <thead> <tr> <th style="text-align: left">Component</th> <th style="text-align: left">Params per layer</th> <th style="text-align: left">Training FLOPs per layer</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>MLP</strong></td> <td style="text-align: left">3DF</td> <td style="text-align: left">18BTDF</td> </tr> <tr> <td style="text-align: left"><strong>Attention</strong></td> <td style="text-align: left">4DNH</td> <td style="text-align: left">24BTDNH + 12BT<sup>2</sup>NH</td> </tr> <tr> <td style="text-align: left"><strong>Other</strong></td> <td style="text-align: left">D</td> <td style="text-align: left">BTD</td> </tr> <tr> <td style="text-align: left"><strong>Vocab</strong></td> <td style="text-align: left">DV (total, not per-layer)</td> <td style="text-align: left">12BTDV</td> </tr> </tbody> </table> <ul> <li>The parameter count of the MLP block dominates the total parameter count and the MLP block also dominates the FLOPs budget as long as the sequence length $T &lt; 8D$.</li> <li>The total FLOPs budget during training is well approximated by \(6 \cdot \text{num_params} \cdot \text{num_tokens}\) for reasonable context lengths.</li> <li>During inference, our KV caches are roughly \(2 \cdot S \cdot L \cdot N \cdot H\) per cache, although architectural modifications can often reduce this.</li> </ul> <h2 id="a-few-problems-to-work">A Few Problems to Work</h2> <p><strong>Question 1:</strong> How many parameters does a model with $D=4096$, $F=4 \cdot D$, $V=32,000$, and $L=64$ have? What fraction of these are attention parameters? How large are our KV caches per token? <em>You can assume $N\cdot H=D$ and multi-head attention with int8 KVs.</em></p> <details><summary>Click here for the answer.</summary> <ol> <li>The total parameters is roughly \(L \cdot (3DF + 4DNH + D) + 2DV\). For the given numbers, this is \(64 \cdot (3 \cdot 4e3 \cdot 16e3 + 4 \cdot 4e3 \cdot 4e3 + 4e3) + 2 \cdot 4e3 \cdot 32e3 = 16e9\), or 16B parameters.</li> <li>The ratio of attention parameters to total parameters in general is \(4DNH / (4DNH + 3DF) = 4D^2 / (4D^2 + 12D^2) = 1/4\). This gives us roughly 1/4 of parameters are used in attention.</li> <li>Per token, our KV caches are \(2 \cdot L \cdot N \cdot H = 2 \cdot 64 \cdot 4096\) in int8, which is <code class="language-plaintext highlighter-rouge">512kB / token</code>.</li> </ol> </details> <p><strong>Question 2:</strong> How many total FLOPs are required to perform A[B<sub>X</sub>, D<sub>Y</sub>] *<sub>D</sub> W[D<sub>Y</sub>, F] on <code class="language-plaintext highlighter-rouge">{‘X': 4, ‘Y': 8, ‘Z': 4}</code>. How many FLOPs are performed by each TPU?</p> <details><summary>Click here for the answer.</summary> <p>The total “theoretical” FLOPs of the operation is \(2 \cdot B \cdot D \cdot F\). However, because the computation isn’t sharded across the Z dimension, we’re actually doing Z extra FLOPs, meaning \(2 \cdot B \cdot D \cdot F \cdot Z\) total FLOPs. Since the computation is sharded across the other dimensions, the total per-device is roughly \(2 \cdot B \cdot D \cdot F / (X \cdot Y)\).</p> </details> <p><strong>Question 3:</strong> How many FLOPs are involved in performing $A[I,J,K,L] * B[I,J,M,N,O] \rightarrow C[K,L,M,N,O]$?</p> <details><summary>Click here for the answer.</summary> <p>Following the rule above, we have I and J as contracting dimensions and K, L, M, N, and O as non-contracting dimensions. We have no “batching dimensions”, so this is just \(2 \cdot I \cdot J \cdot K \cdot L \cdot M \cdot N \cdot O\), the sum of all the axes. If we had a shared axis, it would only be counted once.</p> </details> <p><strong>Question 4:</strong> What is the arithmetic intensity of self-attention (ignoring the Q/K/V/O projections)? <em>Give the answer as a function of the Q and KV lengths T and S.</em> At what context length is attention FLOPs-bound? Given the HBM bandwidth of our TPUs, plot the effective relative cost of attention to the FFW block as the context length grows.</p> <details><summary>Click here for the answer.</summary> <p>Self-attention requires loading the \(Q\), \(K\), and \(V\) activations, then computing \(\text{softmax}(Q \cdot K) \cdot V\), then writing the result back to HBM. This will be done with Flash Attention so there are some caveats to this math, but basically in bf16 self-attention performs</p> \[\text{Q[B,T,N,H]} \rightarrow_\text{reshape} \text{Q[B, T, K, G, H]} \cdot \text{K[B, S, K, H]} \rightarrow \text{O[B, T, S, K, G]}\] \[U=\text{softmax}_S(\text{O[B, T, S, K, G]})\] \[\text{U[B, T, S, K, G]} \cdot \text{V[B, S, K, H]} \rightarrow \text{X[B, T, K, G, H]}\] <p>So our total bytes is \(2 * \text{sizeof}(Q) + 2 * \text{sizeof(K or V)} = 4BTNH + 4BSKH = 4BHK * (TG + S)\), total FLOPs is \(4BTSNH + O(BTSN)\) and the arithmetic intensity is \(4BTSKGH / (4BHK * (TG + S))\).</p> <p>So basically, during prefill we have \(S=T\) so we have an arithmetic intensity of \(4BT^2KGH / 4BHKT \cdot (G+1) = TG/(G + 1) = O(T)\). During generation, \(T=1\) so we have \(4BSKGH / (4BHK \cdot (G + S)) = SG / (G + S) \rightarrow G\) assuming \(S\) is very large. Depending on how you interpret the question, during prefill or training self-attention is compute bound at S=240 assuming no sequence sharding. During generation, we are never compute bound because \(G\) is small. Nonetheless, however, you can see that increasing \(G\) leads to us being closer to compute bound.</p> </details> <p><strong>Question 5:</strong> At what sequence length are self-attention FLOPs equal to the QKVO projection FLOPs?</p> <details><summary>Click here for the answer.</summary> <p>This is purely a question of when \(24BTDNH == 12BT^2NH\). Simplifying we get \(2D = T\), so e.g. for \(D=4096\), this is \(8192\). This tells us that for most reasonable context lengths, matmul FLOPs are greater.</p> </details> <p><strong>Question 6:</strong> Say we only save the output of each of the 7 main matmuls in a Transformer layer during our forward pass (Q, K, V, O + the three FFW matrices). How many extra FLOPs do we need to “rematerialize” during the backwards pass?</p> <p><strong>Question 7:</strong> DeepSeek v3 says it was trained for 2.79M H800 hours on 14.8T tokens (<a href="https://arxiv.org/pdf/2412.19437v1" rel="external nofollow noopener" target="_blank">source</a>). Given that it has 37B activated parameters, roughly what hardware utilization did they achieve? <em>Hint: note that they used FP8 FLOPs without structured sparsity.</em></p> <details><summary>Click here for the answer.</summary> <p>From the spec sheet <a href="https://lenovopress.lenovo.com/lp1814.pdf" rel="external nofollow noopener" target="_blank">here</a>, we find 3,026 TFLOPs/s of FP8 performance with sparsity, or typically half this (<code class="language-plaintext highlighter-rouge">1.513e15</code> FLOPs/s) without sparsity. 2.79M H800 hours means <code class="language-plaintext highlighter-rouge">2.79e6 * 1.513e15 * 60 * 60 = 1.52e25</code> total FLOPs. Given the activated parameter count of 37B, this training run should have used about <code class="language-plaintext highlighter-rouge">6 * 37e9 * 14.8e12 = 3.3e24</code> FLOPs. That means the FLOPs utilization is about <code class="language-plaintext highlighter-rouge">3.3e24 / 1.52e25 = 21.7%</code>.</p> </details> <h3 class="next-section">That’s it for Part 4! For Part 5 (about scaling Transformer training), <a href="../training">click here</a>!</h3> <h2 id="appendix">Appendix</h2> <h3 id="appendix-a-how-does-flash-attention-work">Appendix A: How does Flash Attention work?</h3> <p>The traditional objection to scaling Transformers to very long context is that the attention FLOPs and memory usage scale quadratically with context length. While it’s true that the attention QK product has shape $[B, S, T, N]$ where B is the batch size, S and T are the Q and K sequence dims, and H is the number of heads, this claim comes with some serious caveats:</p> <ol> <li>As we noted in Section 4, even though this is quadratic, the attention FLOPs only dominated when \(S &gt; 8 \cdot D\), and especially during training the memory of a single attention matrix is small compared to all of the weights and activation checkpoints living in memory, especially when sharded.</li> <li>We don’t need to materialize the full attention matrix in order to compute attention! We can compute local sums and maxes and avoid ever materializing more than a small chunk of the array. While the total FLOPs is still quadratic, we drastically reduce memory pressure.</li> </ol> <p>This second observation was first made by <a href="https://arxiv.org/abs/2112.05682" rel="external nofollow noopener" target="_blank">Rabe et al. 2021</a> and later in the <a href="https://arxiv.org/abs/2205.14135" rel="external nofollow noopener" target="_blank">Flash Attention paper</a> (Dao et al. 2022). The basic idea is to compute the attention in chunks of K/V, where we compute the local softmax and some auxiliary statistics, then pass them onto the next chunk which combines them with its local chunk. Specifically, we compute</p> <ol> <li> <strong>M:</strong> The running max of \(q \cdot k\) over the sequence dimension</li> <li> <strong>O:</strong> The running full attention softmax over the sequence dimension</li> <li> <strong>L:</strong> The running denominator \(\sum_i (q \cdot k_i - \text{running max})\)</li> </ol> <p>With these, we can compute the new max, the new running sum, and the new output with only a constant amount of memory. To give a sketchy description of how this works, attention is roughly this operation:</p> \[\text{Attn}(Q, K, V) = \sum_i \frac{\exp(Q \cdot K_i - \max_j Q \cdot K_j) V_i}{\sum_l \exp(Q \cdot K_l - \max_j Q \cdot K_j)}\] <p>The max is subtracted for numerical stability and can be added without affecting the outcome since \(\sum_i \exp(a_i + b) = \exp(b) \sum \exp(a)\). Looking just at the denominator above, if we imagine having two contiguous chunks of key vectors, \(K^1\) and \(K^2\) and we compute the local softmax sums \(L^1\) and \(L^2\) for each</p> \[L^1 = \sum_i \exp(Q \cdot K_i^1 - \max_j Q \cdot K_j^1)\] \[L^2 = \sum_i \exp(Q \cdot K_i^2 - \max_j Q \cdot K_j^1)\] <p>Then we can combine these into the full softmax sum for these two chunks together by using</p> \[L^\text{combined} = \exp(M^1 - \max(M^1, M^2)) \cdot L^1 + \exp(M^2 - \max(M^1, M^2)) \cdot L^2\] <p>where</p> \[M^1 = \max_j Q \cdot K_j^1 \text{ and } M^2 = \max_j Q \cdot K_j^2\] <p>This can be done for the full softmax as well, giving us a way of accumulating arbitrarily large softmax sums. Here’s the full algorithm from the Flash Attention paper.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/scaling-book/assets/img/flash-algo-480.webp 480w,/scaling-book/assets/img/flash-algo-800.webp 800w,/scaling-book/assets/img/flash-algo-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/scaling-book/assets/img/flash-algo.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>From a hardware standpoint, this lets us fit our chunk of Q into VMEM (what the algorithm above calls on-chip SRAM) so we only have to load the KV chunks on each iteration, reducing the arithmetic intensity. We can also keep the running statistics in VMEM.</p> <p>One last subtle point worth emphasizing is an attention softmax property that’s used to make the Flash VJP (reverse mode derivative) calculation practical for training. If we define an intermediate softmax array as:</p> \[S_{ij} = \frac{e^{\tau q_i \cdot k_j}}{\sum_k e^{\tau q_i \cdot k_j}}\] <p>In attention, we obtain <em>dS</em> from reverse-mode <em>dO</em> and <em>V</em> arrays:</p> \[dS_{ij} = dO_{id} \cdot_d V_{jd} = \sum_d dO_{id} V_{jd}\] <p>During the backpropagation of this gradient to Q and K</p> \[d(q_i \cdot k_j) = (dS_{ij} - S_{ij} \cdot_j dS_{ij}) S_{ij}\] <p>We exploit an identity that allows us to exchange a contraction along the large key <strong>length</strong> dimension with a local contraction along the feature <strong>depth</strong> dimension.</p> \[\begin{align*} S_{ij} \cdot_j dS_{ij} &amp;= \sum_j \frac{e^{\tau q_i \cdot k_j}}{\sum_k e^{\tau q_i \cdot k_k}} \sum_d dO_{id} V_{jd} \\ &amp;= \sum_d dO_{id} \sum_j \frac{e^{\tau q_i \cdot k_j}}{\sum_k e^{\tau q_i \cdot k_k}} V_{jd} \\ &amp;= \sum_d dO_{id} O_{id} \\ &amp;= dO_{id} \cdot_d O_{id} \end{align*}\] <p>This replacement is crucial for being able to implement a sequence-block <em>local</em> calculation for the VJP, and enables further clever sharding schemes like ring attention.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> <div class="base-grid appendix-entry"> <h3 style="grid-column: 0;">Miscellaneous</h3> <p class="author-footnote" style="grid-column: text;"><sup>*</sup>Work done at Google DeepMind, now at MatX.</p> </div> <div class="base-grid appendix-entry"> <h3 style="grid-column: 0;">Citation</h3> <p class="author-footnote">For attribution in academic contexts, please cite this work as:</p> <div class="author-footnote"> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">Austin et al., "How to Scale Your Model", Google DeepMind, online, 2025.</span>
</code></pre></div></div> </div> <p class="author-footnote">or as a BibTeX entry:</p> <div class="author-footnote"> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nc">@article</span><span class="p">{</span><span class="nl">scaling-book</span><span class="p">,</span>
      <span class="na">title</span> <span class="p">=</span> <span class="s">{How to Scale Your Model}</span><span class="p">,</span>
      <span class="na">author</span> <span class="p">=</span> <span class="s">{Austin, Jacob and Douglas, Sholto and Frostig, Roy and Levskaya, Anselm and Chen, Charlie and Vikram, Sharad
      and Lebron, Federico and Choy, Peter and Ramasesh, Vinay and Webson, Albert and Pope, Reiner}</span><span class="p">,</span>
      <span class="na">publisher</span> <span class="p">=</span> <span class="s">{Google DeepMind}</span><span class="p">,</span>
      <span class="na">howpublished</span> <span class="p">=</span> <span class="s">{Online}</span><span class="p">,</span>
      <span class="na">note</span> <span class="p">=</span> <span class="s">{Retrieved from https://jax-ml.github.io/scaling-book/}</span><span class="p">,</span>
      <span class="na">year</span> <span class="p">=</span> <span class="s">{2025}</span>
    <span class="p">}</span>
</code></pre></div></div> </div> </div> </d-appendix> <d-bibliography src="/scaling-book/assets/bibliography/main.bib"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'jax-ml/scaling-book',
        'data-repo-id': '',
        'data-category': 'General',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '0',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-loading': '1',
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/scaling-book/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/scaling-book/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/scaling-book/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/scaling-book/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/scaling-book/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/scaling-book/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/scaling-book/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/scaling-book/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/scaling-book/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> </body> </html>